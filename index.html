<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Market Sandbox ‚Äî Pro (Pan/Zoom + Tools)</title>
  <style>
    :root{
      --bg:#0b0f14;
      --text:#e7eef7;
      --muted:#9fb0c3;
      --line:#223044;
      --shadow: 0 10px 30px rgba(0,0,0,.35);
      --radius: 14px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, "Noto Sans", "Liberation Sans", sans-serif;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family:var(--sans);
      background: radial-gradient(1200px 800px at 10% 10%, #101a2a 0%, var(--bg) 45%) fixed;
      color:var(--text);
    }
    header{
      padding:16px 18px;
      border-bottom:1px solid var(--line);
      background: linear-gradient(180deg, rgba(17,24,36,.85), rgba(11,15,20,.55));
      position:sticky; top:0; z-index:3;
      backdrop-filter: blur(8px);
    }
    header .row{
      display:flex; align-items:center; justify-content:space-between; gap:12px;
      max-width:1400px; margin:0 auto;
    }
    .title{display:flex; flex-direction:column; gap:2px;}
    .title h1{font-size:16px; margin:0; font-weight:700; letter-spacing:.2px;}
    .title .sub{font-size:12px; color:var(--muted);}

    .pill{
      display:inline-flex; gap:10px; align-items:center;
      padding:8px 10px;
      background: rgba(17,24,36,.75);
      border:1px solid rgba(34,48,68,.9);
      border-radius:999px;
      box-shadow: var(--shadow);
      font-size:12px;
      color:var(--muted);
      white-space:nowrap;
    }
    .pill b{color:var(--text); font-weight:700}

    main{
      max-width:1400px;
      margin:0 auto;
      padding:14px;
      display:grid;
      grid-template-columns: 420px 1fr 420px;
      gap:14px;
    }
    .card{
      background: linear-gradient(180deg, rgba(17,24,36,.9), rgba(15,22,32,.82));
      border:1px solid rgba(34,48,68,.9);
      border-radius:var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
      min-height: 140px;
    }
    .card h2{
      margin:0;
      padding:12px 12px 10px;
      font-size:13px;
      letter-spacing:.2px;
      border-bottom:1px solid rgba(34,48,68,.7);
      color: #dce8f7;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }
    .card h2 small{color:var(--muted); font-weight:600; font-size:11px;}
    .card .content{padding:12px;}
    .grid{display:grid; gap:10px;}
    .grid.cols2{grid-template-columns:1fr 1fr;}
    .grid.cols3{grid-template-columns:1fr 1fr 1fr;}

    label{display:flex; flex-direction:column; gap:6px; font-size:11px; color:var(--muted);}
    input, select, button{font-family:inherit;}
    input, select{
      width:100%;
      padding:10px 10px;
      border-radius:10px;
      border:1px solid rgba(34,48,68,.9);
      background: rgba(11,15,20,.55);
      color: var(--text);
      outline:none;
    }
    input:focus, select:focus{
      border-color: rgba(100,181,255,.9);
      box-shadow: 0 0 0 3px rgba(100,181,255,.15);
    }
    .btn{
      border:none;
      border-radius:12px;
      padding:11px 12px;
      cursor:pointer;
      font-weight:800;
      letter-spacing:.2px;
      user-select:none;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      gap:8px;
      white-space:nowrap;
      background: rgba(159,176,195,.12);
      color:#e7eef7;
      border:1px solid rgba(159,176,195,.35);
      transition: transform .06s ease, opacity .15s ease;
    }
    .btn:active{transform: translateY(1px);}
    .btn.good{background: rgba(61,220,151,.16); color: #bdf8de; border:1px solid rgba(61,220,151,.45);}
    .btn.bad{background: rgba(255,91,110,.14); color: #ffd0d7; border:1px solid rgba(255,91,110,.45);}
    .btn.neutral{background: rgba(100,181,255,.14); color: #d4ebff; border:1px solid rgba(100,181,255,.45);}
    .btn.warn{background: rgba(255,207,91,.12); color: #ffe8b2; border:1px solid rgba(255,207,91,.35);}
    .btn.small{padding:8px 10px; border-radius:10px; font-size:12px; font-weight:800;}
    .btn.tiny{padding:7px 9px; border-radius:10px; font-size:12px; font-weight:800;}

    .row{display:flex; gap:10px; align-items:center;}
    .row.wrap{flex-wrap:wrap;}

    .stat{
      display:flex; flex-direction:column; gap:2px;
      padding:10px 10px;
      border-radius:12px;
      border:1px solid rgba(34,48,68,.7);
      background: rgba(11,15,20,.35);
      min-width: 0;
    }
    .stat .k{font-size:11px; color:var(--muted);}
    .stat .v{font-family:var(--mono); font-size:13px; font-weight:800; color:var(--text); overflow:hidden; text-overflow:ellipsis; white-space:nowrap;}

    .chartTopBar{
      padding:12px;
      border-bottom:1px solid rgba(34,48,68,.7);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      flex-wrap:wrap;
    }
    .chartTopBar .left{display:flex; gap:10px; align-items:center; flex-wrap:wrap;}
    .chartTopBar .right{display:flex; gap:10px; align-items:center; flex-wrap:wrap;}
    .miniField{
      display:flex; align-items:center; gap:8px;
      padding:8px 10px;
      border-radius:12px;
      border:1px solid rgba(34,48,68,.7);
      background: rgba(11,15,20,.35);
      color: var(--muted);
      font-size:12px;
    }
    .miniField input{width:90px; padding:8px 8px; border-radius:10px; font-size:12px;}
    .miniField select{width:140px; padding:8px 8px; border-radius:10px; font-size:12px;}
    .toggle{
      display:flex; align-items:center; gap:8px;
      padding:8px 10px;
      border-radius:12px;
      border:1px solid rgba(34,48,68,.7);
      background: rgba(11,15,20,.35);
      color: var(--muted);
      font-size:12px;
      user-select:none;
      cursor:pointer;
    }
    .toggle input{width:auto; transform: translateY(1px);}

    .chartWrap{height: 520px; padding: 10px 12px 12px;}
    canvas{
      width:100%;
      height:100%;
      display:block;
      border-radius:12px;
      border:1px solid rgba(34,48,68,.7);
      background: rgba(5,8,12,.65);
      cursor: crosshair;
      touch-action: none;
    }

    table{width:100%; border-collapse:collapse; font-size:12px;}
    thead th{
      text-align:left;
      color: var(--muted);
      font-size:11px;
      font-weight:700;
      padding:10px 8px;
      border-bottom:1px solid rgba(34,48,68,.7);
    }
    tbody td{
      padding:9px 8px;
      border-bottom:1px solid rgba(34,48,68,.35);
      vertical-align:top;
      font-family: var(--mono);
    }
    tbody tr:hover{background: rgba(100,181,255,.06);}
    .tag{
      font-family: var(--mono);
      font-size:11px;
      padding:3px 6px;
      border-radius:999px;
      border:1px solid rgba(34,48,68,.8);
      background: rgba(11,15,20,.35);
      color: var(--muted);
    }
    .tag.buy{border-color: rgba(61,220,151,.45); color:#bdf8de; background: rgba(61,220,151,.10);}
    .tag.sell{border-color: rgba(255,91,110,.45); color:#ffd0d7; background: rgba(255,91,110,.10);}

    .mono{font-family:var(--mono)}
    .muted{color:var(--muted)}
    .hint{font-size:12px; color: var(--muted); line-height:1.35;}
    .sep{height:1px; background: rgba(34,48,68,.7); margin: 12px 0;}

    .log{
      height: 240px;
      overflow:auto;
      border-radius:12px;
      border:1px solid rgba(34,48,68,.7);
      background: rgba(11,15,20,.35);
      padding:10px;
      font-family: var(--mono);
      font-size:12px;
      line-height:1.35;
    }
    .log div{padding:3px 0; border-bottom:1px dashed rgba(34,48,68,.35);}
    .log div:last-child{border-bottom:none;}

    .rightSticky{
      position:sticky;
      top:74px;
      height: calc(100vh - 88px);
      overflow:auto;
      padding-bottom: 16px;
    }
    .leftSticky{
      position:sticky;
      top:74px;
      height: calc(100vh - 88px);
      overflow:auto;
      padding-bottom: 16px;
    }
    .toolRow{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      align-items:center;
    }
    .toolBtn{
      padding:7px 10px;
      border-radius:10px;
      border:1px solid rgba(34,48,68,.7);
      background: rgba(11,15,20,.35);
      color: var(--muted);
      font-weight:800;
      cursor:pointer;
      user-select:none;
      font-size:12px;
    }
    .toolBtn.active{
      border-color: rgba(100,181,255,.75);
      color: #d4ebff;
      background: rgba(100,181,255,.10);
    }

    @media (max-width: 1220px){
      main{grid-template-columns: 1fr;}
      .rightSticky,.leftSticky{position:static; height:auto;}
      .chartWrap{height:420px;}
      .miniField input{width:110px;}
      .miniField select{width:160px;}
    }
  </style>
</head>

<body>
<header>
  <div class="row">
    <div class="title">
      <h1>Market Sandbox ‚Äî Pro üïπÔ∏è</h1>
      <div class="sub">–ü–∞–Ω/–∑—É–º –≥—Ä–∞—Ñ–∏–∫–∞ + –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã (–ª–∏–Ω–∏–∏/–±–æ–∫—Å—ã/–∑–æ–Ω—ã). –°–≤–µ—á–∏ –ø–ª–∞–≤–Ω–æ, –±–µ–∑ TP/SL.</div>
    </div>

    <div class="row wrap">
      <div class="pill">–ò–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç: <b id="sym">NQ (sim)</b></div>
      <div class="pill">–¶–µ–Ω–∞: <b id="hdrPrice">‚Äî</b></div>
      <div class="pill">–ü–æ–∑–∏—Ü–∏—è: <b id="hdrPos">0</b></div>
      <div class="pill">Flow: <b id="hdrFlow">0</b></div>
    </div>
  </div>
</header>

<main>
  <!-- LEFT -->
  <div class="leftSticky">
    <section class="card">
      <h2>–õ–∏–º–∏—Ç–∫–∏ –∏ —É—Ä–æ–≤–Ω–∏ <small>control</small></h2>
      <div class="content grid">

        <div class="grid cols2">
          <label>–ö–æ–ª-–≤–æ (qty)
            <input id="qty" type="number" step="1" min="1" value="1" />
          </label>
          <label>–ü—Ä–æ—Å–∫–∞–ª—å–∑—ã–≤–∞–Ω–∏–µ (ticks)
            <input id="slip" type="number" step="1" min="0" value="1" />
          </label>
        </div>

        <div class="sep"></div>

        <div class="grid cols2">
          <label>–¢–∏–ø –ª–∏–º–∏—Ç–∫–∏
            <select id="limitSide">
              <option value="buy">Limit Buy</option>
              <option value="sell">Limit Sell</option>
            </select>
          </label>
          <label>–¶–µ–Ω–∞ –ª–∏–º–∏—Ç–∫–∏
            <input id="limitPrice" type="number" step="0.25" value="0" />
          </label>
        </div>
        <button class="btn neutral" id="placeLimit">‚ûï –ü–æ—Å—Ç–∞–≤–∏—Ç—å Limit</button>

        <div class="sep"></div>

        <div class="grid cols3">
          <label>–õ–µ—Å—Ç–Ω–∏—Ü–∞: side
            <select id="ladderSide">
              <option value="buy">Buy ladder</option>
              <option value="sell">Sell ladder</option>
            </select>
          </label>
          <label>Levels
            <input id="ladderLevels" type="number" step="1" min="1" value="8" />
          </label>
          <label>Step (pts)
            <input id="ladderStep" type="number" step="0.25" min="0.25" value="5" />
          </label>
        </div>
        <div class="grid cols2">
          <label>Start price
            <input id="ladderStart" type="number" step="0.25" value="0" />
          </label>
          <label>Qty per level
            <input id="ladderQty" type="number" step="1" min="1" value="1" />
          </label>
        </div>
        <button class="btn warn" id="placeLadder">ü™ú –ü–æ—Å—Ç–∞–≤–∏—Ç—å –ª–µ—Å—Ç–Ω–∏—Ü—É</button>

        <div class="sep"></div>

        <div class="grid cols2">
          <label>–°–¥–≤–∏–≥ –≤—Å–µ—Ö –ª–∏–º–∏—Ç–æ–∫ (pts)
            <input id="shiftPts" type="number" step="0.25" value="1" />
          </label>
          <div class="grid cols2" style="align-items:end">
            <button class="btn small" id="shiftUp">‚¨ÜÔ∏è Shift +</button>
            <button class="btn small" id="shiftDn">‚¨áÔ∏è Shift ‚àí</button>
          </div>
        </div>

        <div class="grid cols2">
          <button class="btn" id="cancelAll">üßπ Cancel All</button>
          <button class="btn" id="flatten">üßØ Flatten (mkt)</button>
        </div>

        <div class="hint">
          –ü–∞–Ω/–∑—É–º ‚Äî –Ω–∞ –≥—Ä–∞—Ñ–∏–∫–µ. –ï—Å–ª–∏ –≤–∫–ª—é—á—ë–Ω <b>Auto-follow</b>, –æ–Ω –±—É–¥–µ—Ç –¥–µ—Ä–∂–∞—Ç—å —Ü–µ–Ω—É ‚Äú–≤ –∫–æ–Ω—Ü–µ‚Äù.
        </div>
      </div>
    </section>

    <section class="card" style="margin-top:14px">
      <h2>–î–≤–∏–∂–æ–∫ —Ä—ã–Ω–∫–∞ <small>smooth + TF</small></h2>
      <div class="content grid">
        <div class="grid cols2">
          <label>Volatility (1‚Äì20)
            <input id="vol" type="number" step="1" min="1" max="20" value="8" />
          </label>
          <label>Liquidity (1‚Äì20)
            <input id="liq" type="number" step="1" min="1" max="20" value="10" />
          </label>
        </div>

        <div class="grid cols2">
          <label>Impact (0‚Äì20)
            <input id="impact" type="number" step="1" min="0" max="20" value="8" />
          </label>
          <label>Sim ticks/sec (5‚Äì120)
            <input id="simHz" type="number" step="1" min="5" max="120" value="60" />
          </label>
        </div>

        <div class="grid cols2">
          <label>Tick size
            <input id="tick" type="number" step="0.01" min="0.01" value="0.25" />
          </label>
          <label>Spread (ticks)
            <input id="spread" type="number" step="1" min="0" value="1" />
          </label>
        </div>

        <div class="grid cols2">
          <label>–¢–∞–π–º—Ñ—Ä–µ–π–º (—Å–∏–º)
            <select id="timeframe">
              <option value="1s">1s</option>
              <option value="5s" selected>5s</option>
              <option value="15s">15s</option>
              <option value="1m">1m</option>
              <option value="5m">5m</option>
            </select>
          </label>
          <label>–°–≤–µ—á–µ–π –Ω–∞ —ç–∫—Ä–∞–Ω–µ
            <input id="visibleBars" type="number" step="5" min="20" max="600" value="140" />
          </label>
        </div>

        <div class="grid cols2">
          <button class="btn neutral" id="pause">‚è∏Ô∏è Pause</button>
          <button class="btn neutral" id="reset">üîÅ Reset</button>
        </div>
      </div>
    </section>
  </div>

  <!-- CENTER -->
  <section class="card">
    <h2>–ì—Ä–∞—Ñ–∏–∫ (–ø–∞–Ω/–∑—É–º + –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã) <small>–∫–∞–∫ —Ç–µ—Ä–º–∏–Ω–∞–ª</small></h2>

    <div class="chartTopBar">
      <div class="left">
        <button class="btn good" id="buyMktTop">‚¨ÜÔ∏è Buy Market</button>
        <button class="btn bad" id="sellMktTop">‚¨áÔ∏è Sell Market</button>
        <div class="miniField">qty <input id="qtyTop" type="number" step="1" min="1" value="1" /></div>
        <div class="miniField">slip <input id="slipTop" type="number" step="1" min="0" value="1" /></div>

        <div class="toggle" id="followWrap" title="–ï—Å–ª–∏ –≤–∫–ª—é—á–µ–Ω–æ ‚Äî –≥—Ä–∞—Ñ–∏–∫ –¥–µ—Ä–∂–∏—Ç—Å—è –Ω–∞ –ø–æ—Å–ª–µ–¥–Ω–µ–π —Å–≤–µ—á–µ">
          <input id="follow" type="checkbox" checked />
          <span>Auto-follow</span>
        </div>
      </div>

      <div class="right">
        <div class="miniField">
          Tool
          <select id="tool">
            <option value="pan">Pan</option>
            <option value="select">Select</option>
            <option value="line">Line</option>
            <option value="box">Box</option>
            <option value="zone">Zone</option>
            <option value="hline">HLine</option>
            <option value="vline">VLine</option>
          </select>
        </div>
        <button class="btn tiny" id="delShape">Delete</button>
        <button class="btn tiny" id="clearShapes">Clear</button>
        <div class="miniField mono" title="–ö–æ–ª–µ—Å–æ ‚Äî –∑—É–º. Drag ‚Äî –ø–∞–Ω. Shift+drag ‚Äî –ø–∞–Ω –¥–∞–∂–µ –≤ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∞—Ö.">Wheel=Zoom Drag=Pan</div>
      </div>
    </div>

    <div class="chartWrap">
      <canvas id="chart" width="1200" height="520"></canvas>
    </div>

    <div class="content">
      <div class="row wrap">
        <div class="stat"><div class="k">Last</div><div class="v" id="stLast">‚Äî</div></div>
        <div class="stat"><div class="k">Bid / Ask</div><div class="v" id="stBA">‚Äî</div></div>
        <div class="stat"><div class="k">Net Position</div><div class="v" id="stPos">0</div></div>
        <div class="stat"><div class="k">Avg Price</div><div class="v" id="stAvg">‚Äî</div></div>
        <div class="stat"><div class="k">Flow (recent)</div><div class="v" id="stFlow">0</div></div>
        <div class="stat"><div class="k">Visible window</div><div class="v" id="stWin">‚Äî</div></div>
      </div>
      <div class="hint" style="margin-top:10px">
        –ü–æ–¥—Å–∫–∞–∑–∫–∏: <b>Wheel</b> ‚Äî –∑—É–º; <b>Drag</b> ‚Äî –ø–∞–Ω; –µ—Å–ª–∏ —Ä–∏—Å—É–µ—à—å –∏ —Ö–æ—á–µ—à—å –±—ã—Å—Ç—Ä–æ –ø–∞–Ω–∏—Ç—å ‚Äî –¥–µ—Ä–∂–∏ <b>Shift</b> –∏ —Ç–∞—â–∏.
      </div>
    </div>
  </section>

  <!-- RIGHT -->
  <div class="rightSticky">
    <section class="card">
      <h2>–ê–∫—Ç–∏–≤–Ω—ã–µ –ª–∏–º–∏—Ç–∫–∏ <small>click ‚Üí cancel</small></h2>
      <div class="content" style="padding:0">
        <div style="max-height:320px; overflow:auto">
          <table>
            <thead>
              <tr>
                <th style="width:70px">Side</th>
                <th>Price</th>
                <th>Qty</th>
                <th>Left</th>
                <th style="width:90px">ID</th>
              </tr>
            </thead>
            <tbody id="ordersBody"></tbody>
          </table>
        </div>
      </div>
    </section>

    <section class="card" style="margin-top:14px">
      <h2>–õ–æ–≥ —Å–æ–±—ã—Ç–∏–π <small>fills/cancel</small></h2>
      <div class="content">
        <div class="log" id="log"></div>
        <div class="row wrap" style="margin-top:10px">
          <button class="btn small" id="clearLog">üßΩ Clear log</button>
          <span class="hint">–ö–ª–∏–∫ –ø–æ –æ—Ä–¥–µ—Ä—É ‚Äî –æ—Ç–º–µ–Ω–∞. Select ‚Üí Delete –¥–ª—è —Ñ–∏–≥—É—Ä.</span>
        </div>
      </div>
    </section>
  </div>
</main>

<script>
(() => {
  const $ = (id) => document.getElementById(id);
  const now = () => new Date().toLocaleTimeString();
  const clamp = (x, a, b) => Math.max(a, Math.min(b, x));
  const roundTo = (x, step) => Math.round(x / step) * step;

  const state = {
    symbol: "NQ (sim)",
    tickSize: 0.25,
    spreadTicks: 1,
    volatility: 8,
    liquidity: 10,
    impact: 8,
    simHz: 60,
    paused: false,

    price: 17000,
    velocity: 0,
    flow: 0,
    flowDecay: 0.94,

    pos: 0,
    avg: null,

    // bars (absolute index)
    bars: [],               // {idx,o,h,l,c}
    lastBarIdx: 0,
    barTicks: 300,          // set by TF
    _barCounter: 0,
    _curBar: null,

    // limits
    nextOrderId: 1,
    limits: [], // {id, side, price, qty, left, createdAt}

    // view (pan/zoom)
    visibleBars: 140,       // number of bars visible
    rightOffset: 0,         // how many bars back from the end (0 = last)
    follow: true,           // auto-follow

    // drawing tools
    shapes: [],             // {id,type,a:{idx,price},b:{idx,price}, ...}
    nextShapeId: 1,
    selectedShapeId: null,
    activeTool: "pan",

    // interaction
    dragging: false,
    dragMode: null,         // "pan" | "draw"
    dragStart: null,
    tempShape: null,
  };

  $("sym").textContent = state.symbol;

  function log(msg, kind="") {
    const el = $("log");
    const line = document.createElement("div");
    line.innerHTML = `<span class="muted">[${now()}]</span> ${msg}`;
    if (kind === "good") line.style.color = "#bdf8de";
    if (kind === "bad")  line.style.color = "#ffd0d7";
    if (kind === "warn") line.style.color = "#ffe8b2";
    el.prepend(line);
  }

  function getBidAsk() {
    const spread = state.spreadTicks * state.tickSize;
    const mid = state.price;
    return { bid: mid - spread/2, ask: mid + spread/2 };
  }

  function applyFill(side, qty, fillPrice, reason="") {
    const oldPos = state.pos;
    const newPos = oldPos + (side === "buy" ? qty : -qty);

    if (oldPos === 0) state.avg = fillPrice;
    else if (Math.sign(oldPos) === Math.sign(newPos) && newPos !== 0) {
      const oldAbs = Math.abs(oldPos);
      const newAbs = Math.abs(newPos);
      const addQty = newAbs - oldAbs;
      if (addQty > 0) state.avg = (state.avg * oldAbs + fillPrice * addQty) / newAbs;
    } else if (newPos === 0) state.avg = null;
    else if (Math.sign(oldPos) !== Math.sign(newPos)) state.avg = fillPrice;

    state.pos = newPos;
    state.flow += (side === "buy" ? qty : -qty);

    const tag = side === "buy" ? "üü¢" : "üî¥";
    log(`${tag} FILLED <span class="mono">${side.toUpperCase()}</span> qty=<span class="mono">${qty}</span> @ <span class="mono">${fillPrice.toFixed(2)}</span> ${reason ? `<span class="muted">(${reason})</span>` : ""}`,
      side === "buy" ? "good" : "bad"
    );
  }

  function marketOrder(side, qty, slipTicks) {
    const { bid, ask } = getBidAsk();
    const slip = slipTicks * state.tickSize;
    const fill = side === "buy" ? (ask + slip) : (bid - slip);
    applyFill(side, qty, fill, "market");
  }

  function placeLimit(side, price, qty) {
    price = roundTo(price, state.tickSize);
    const id = state.nextOrderId++;
    state.limits.push({ id, side, price, qty, left: qty, createdAt: Date.now() });
    log(`‚ûï LIMIT <span class="mono">${side.toUpperCase()}</span> qty=<span class="mono">${qty}</span> @ <span class="mono">${price.toFixed(2)}</span> <span class="muted">(id=${id})</span>`, "warn");
  }

  function cancelOrder(id) {
    const idx = state.limits.findIndex(o => o.id === id);
    if (idx >= 0) {
      const o = state.limits[idx];
      state.limits.splice(idx, 1);
      log(`‚úñ CANCEL id=<span class="mono">${id}</span> (${o.side} @ ${o.price.toFixed(2)}, left=${o.left})`, "warn");
    }
  }

  function cancelAll() {
    const n = state.limits.length;
    state.limits = [];
    log(`üßπ Cancel All (${n} orders)`, "warn");
  }

  function shiftAll(deltaPts) {
    const delta = roundTo(deltaPts, state.tickSize);
    state.limits.forEach(o => o.price = roundTo(o.price + delta, state.tickSize));
    log(`‚Üï Shift all limits by <span class="mono">${delta.toFixed(2)}</span> pts`, "warn");
  }

  function flatten() {
    if (state.pos === 0) { log("üßØ Flatten: –ø–æ–∑–∏—Ü–∏—è —É–∂–µ 0", "warn"); return; }
    const qty = Math.abs(state.pos);
    const side = state.pos > 0 ? "sell" : "buy";
    marketOrder(side, qty, getSlip());
    log("üßØ Flatten done", "warn");
  }

  function placeLadder(side, start, levels, step, qtyPerLevel) {
    start = roundTo(start, state.tickSize);
    step = roundTo(Math.max(state.tickSize, step), state.tickSize);
    for (let i = 0; i < levels; i++) {
      const p = side === "buy" ? start - i * step : start + i * step;
      placeLimit(side, p, qtyPerLevel);
    }
  }

  function matchLimits() {
    const { bid, ask } = getBidAsk();
    const liq = clamp(state.liquidity, 1, 20);

    state.limits.sort((a,b)=>a.createdAt-b.createdAt);

    const filledIds = [];
    for (const o of state.limits) {
      if (o.left <= 0) { filledIds.push(o.id); continue; }

      const canFill = (o.side === "buy") ? (ask <= o.price) : (bid >= o.price);
      if (!canFill) continue;

      const baseChunk = Math.max(1, Math.round(o.qty * (21 - liq) / 20));
      const chunk = Math.min(o.left, baseChunk);

      o.left -= chunk;
      applyFill(o.side, chunk, o.price, `limit id=${o.id}`);

      if (o.left <= 0) filledIds.push(o.id);
    }
    if (filledIds.length) state.limits = state.limits.filter(o => !filledIds.includes(o.id));
  }

  function timeframeToBarTicks(tf, simHz) {
    // barTicks = how many sim ticks per bar
    if (tf === "1s") return Math.max(2, Math.round(1 * simHz));
    if (tf === "5s") return Math.max(2, Math.round(5 * simHz));
    if (tf === "15s") return Math.max(2, Math.round(15 * simHz));
    if (tf === "1m") return Math.max(2, Math.round(60 * simHz));
    if (tf === "5m") return Math.max(2, Math.round(300 * simHz));
    return Math.max(2, Math.round(5 * simHz));
  }

  function ensureCurrentBar() {
    if (!state._curBar) {
      state._curBar = { idx: state.lastBarIdx + 1, o: state.price, h: state.price, l: state.price, c: state.price };
      state._barCounter = 0;
    }
  }

  function updateBarsWithPrice(p) {
    ensureCurrentBar();
    state._curBar.h = Math.max(state._curBar.h, p);
    state._curBar.l = Math.min(state._curBar.l, p);
    state._curBar.c = p;

    state._barCounter++;
    if (state._barCounter >= state.barTicks) {
      // close bar
      state.lastBarIdx = state._curBar.idx;
      state.bars.push(state._curBar);
      // keep a lot, but not infinite
      if (state.bars.length > 5000) state.bars.shift();

      // start next
      state._curBar = { idx: state.lastBarIdx + 1, o: p, h: p, l: p, c: p };
      state._barCounter = 0;

      // if follow enabled, keep window at the end
      if (state.follow) state.rightOffset = 0;
    }
  }

  // ===== Smooth simulation step
  function stepSimulationOnce() {
    state.flow *= state.flowDecay;

    const vol = clamp(state.volatility, 1, 20);
    const r = (Math.random()+Math.random()+Math.random()+Math.random()-2);
    const noise = r * (vol * state.tickSize * 0.18);

    const imp = clamp(state.impact, 0, 20);
    const liq = clamp(state.liquidity, 1, 20);
    const pressure = (state.flow) * (imp * state.tickSize * 0.045) * (1 / (liq * 0.40));

    state.velocity = (state.velocity * 0.92) + noise + pressure;
    state.price = roundTo(state.price + state.velocity, state.tickSize);

    updateBarsWithPrice(state.price);
    matchLimits();
  }

  // ===== Canvas + Pan/Zoom + Tools
  const canvas = $("chart");
  const ctx = canvas.getContext("2d");

  function getAllBarsForRender() {
    // include unfinished bar at end
    const arr = state.bars.slice();
    if (state._curBar) arr.push(state._curBar);
    return arr;
  }

  function getWindowBars() {
    const bars = getAllBarsForRender();
    const n = bars.length;
    if (n === 0) return {bars:[], startIdx:0, endIdx:0};

    const vis = clamp(state.visibleBars, 20, 600);
    const end = Math.max(0, n - 1 - state.rightOffset);
    const start = Math.max(0, end - vis + 1);
    return { bars: bars.slice(start, end + 1), startPos: start, endPos: end, total: n };
  }

  function computePriceRange(windowBars) {
    let min = Infinity, max = -Infinity;
    for (const b of windowBars) { min = Math.min(min, b.l); max = Math.max(max, b.h); }
    for (const o of state.limits) { min = Math.min(min, o.price); max = Math.max(max, o.price); }

    // include shapes in range so they don't disappear vertically (optional but nice)
    for (const s of state.shapes) {
      if (s.a?.price != null) { min = Math.min(min, s.a.price); max = Math.max(max, s.a.price); }
      if (s.b?.price != null) { min = Math.min(min, s.b.price); max = Math.max(max, s.b.price); }
    }

    if (!Number.isFinite(min) || !Number.isFinite(max) || min === max) {
      min = state.price - 50 * state.tickSize;
      max = state.price + 50 * state.tickSize;
    }
    const pad = (max-min) * 0.12 + state.tickSize * 20;
    return { min: min - pad, max: max + pad };
  }

  // coordinate transforms
  function makeTransform(windowBars, startPos, endPos, pr, w, h) {
    const n = windowBars.length;
    const candleW = Math.max(3, Math.floor(w / (n + 10)));
    const gap = Math.max(1, Math.floor(candleW * 0.35));
    const step = candleW + gap;
    const totalW = step * n;
    const xStart = Math.max(6, Math.floor((w - totalW) / 2));

    const yOf = (price) => h - ((price - pr.min) / (pr.max - pr.min)) * h;
    const priceOfY = (y) => pr.min + (1 - y / h) * (pr.max - pr.min);

    const xOfIndexInWindow = (i) => xStart + i * step + candleW/2;
    const idxAtX = (x) => {
      const rel = (x - xStart);
      const i = Math.round(rel / step);
      return clamp(i, 0, n-1);
    };

    return { candleW, gap, step, xStart, yOf, priceOfY, xOfIndexInWindow, idxAtX };
  }

  function drawGrid(w,h){
    ctx.lineWidth = 1;
    ctx.strokeStyle = "rgba(34,48,68,0.55)";
    for (let i=1;i<8;i++){
      const y = (h/8)*i;
      ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(w,y); ctx.stroke();
    }
    for (let i=1;i<12;i++){
      const x = (w/12)*i;
      ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,h); ctx.stroke();
    }
  }

  function drawCandles(windowBars, tf, w,h){
    const { candleW, gap, step, xStart, yOf } = tf;
    const n = windowBars.length;

    // bid/ask band
    const {bid, ask} = getBidAsk();
    const yBid = yOf(bid), yAsk = yOf(ask);
    ctx.fillStyle = "rgba(159,176,195,0.08)";
    ctx.fillRect(0, Math.min(yBid,yAsk), w, Math.abs(yBid-yAsk));

    for (let i=0; i<n; i++) {
      const b = windowBars[i];
      const x = xStart + i * step;
      const yO = yOf(b.o), yH = yOf(b.h), yL = yOf(b.l), yC = yOf(b.c);
      const up = b.c >= b.o;

      // wick
      ctx.strokeStyle = up ? "rgba(61,220,151,0.85)" : "rgba(255,91,110,0.85)";
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.moveTo(x + candleW/2, yH);
      ctx.lineTo(x + candleW/2, yL);
      ctx.stroke();

      // body
      const bodyTop = Math.min(yO, yC);
      const bodyH = Math.max(2, Math.abs(yC - yO));
      ctx.fillStyle = up ? "rgba(61,220,151,0.30)" : "rgba(255,91,110,0.28)";
      ctx.strokeStyle = up ? "rgba(61,220,151,0.95)" : "rgba(255,91,110,0.95)";
      ctx.lineWidth = 1.5;
      ctx.fillRect(x, bodyTop, candleW, bodyH);
      ctx.strokeRect(x, bodyTop, candleW, bodyH);
    }
  }

  function drawLimits(tf, w){
    const { yOf } = tf;
    for (const o of state.limits) {
      const y = yOf(o.price);
      ctx.strokeStyle = o.side === "buy" ? "rgba(61,220,151,0.65)" : "rgba(255,91,110,0.65)";
      ctx.lineWidth = 1.5;
      ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(w,y); ctx.stroke();

      ctx.fillStyle = o.side === "buy" ? "rgba(61,220,151,0.9)" : "rgba(255,91,110,0.9)";
      ctx.font = "12px " + getComputedStyle(document.body).fontFamily;
      ctx.fillText(`${o.side.toUpperCase()} ${o.price.toFixed(2)} (left ${o.left})`, 10, y - 6);
    }
  }

  function inWindowIdx(idx, winFirstIdx, winLastIdx) {
    return idx >= winFirstIdx && idx <= winLastIdx;
  }

  function drawShapes(tf, windowBars){
    const { yOf, xOfIndexInWindow } = tf;
    if (!windowBars.length) return;

    const winFirstIdx = windowBars[0].idx;
    const winLastIdx  = windowBars[windowBars.length-1].idx;

    function toX(idx){
      const i = idx - winFirstIdx;
      if (i < 0 || i >= windowBars.length) return null;
      return xOfIndexInWindow(i);
    }

    for (const s of state.shapes) {
      const selected = (s.id === state.selectedShapeId);
      const aIn = s.a && inWindowIdx(s.a.idx, winFirstIdx, winLastIdx);
      const bIn = s.b && inWindowIdx(s.b.idx, winFirstIdx, winLastIdx);

      ctx.lineWidth = selected ? 2.5 : 2;

      if (s.type === "hline" && s.a) {
        const y = yOf(s.a.price);
        ctx.strokeStyle = selected ? "rgba(100,181,255,0.95)" : "rgba(100,181,255,0.65)";
        ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(canvas.width,y); ctx.stroke();
        continue;
      }
      if (s.type === "vline" && s.a && aIn) {
        const x = toX(s.a.idx);
        ctx.strokeStyle = selected ? "rgba(255,207,91,0.95)" : "rgba(255,207,91,0.65)";
        ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,canvas.height); ctx.stroke();
        continue;
      }

      if (!s.a || !s.b) continue;
      if (!aIn && !bIn) continue; // both outside window

      const x1 = toX(clamp(s.a.idx, winFirstIdx, winLastIdx));
      const x2 = toX(clamp(s.b.idx, winFirstIdx, winLastIdx));
      if (x1 == null || x2 == null) continue;

      const y1 = yOf(s.a.price);
      const y2 = yOf(s.b.price);

      if (s.type === "line") {
        ctx.strokeStyle = selected ? "rgba(159,176,195,0.95)" : "rgba(159,176,195,0.65)";
        ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();
      } else if (s.type === "box" || s.type === "zone") {
        const left = Math.min(x1,x2);
        const top  = Math.min(y1,y2);
        const w = Math.abs(x2-x1);
        const h = Math.abs(y2-y1);

        ctx.strokeStyle = selected ? "rgba(159,176,195,0.95)" : "rgba(159,176,195,0.65)";
        ctx.strokeRect(left, top, w, h);

        if (s.type === "zone") {
          ctx.fillStyle = selected ? "rgba(100,181,255,0.10)" : "rgba(100,181,255,0.07)";
          ctx.fillRect(left, top, w, h);
        }
      }
    }

    // temp shape preview
    if (state.tempShape) {
      const s = state.tempShape;
      ctx.lineWidth = 2;
      ctx.setLineDash([6,4]);
      ctx.strokeStyle = "rgba(100,181,255,0.75)";
      if (s.type === "hline" && s.a) {
        const y = yOf(s.a.price);
        ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(canvas.width,y); ctx.stroke();
      } else if (s.type === "vline" && s.a) {
        const aIn2 = inWindowIdx(s.a.idx, winFirstIdx, winLastIdx);
        if (aIn2) {
          const x = toX(s.a.idx);
          ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,canvas.height); ctx.stroke();
        }
      } else if (s.a && s.b) {
        const x1 = toX(clamp(s.a.idx, winFirstIdx, winLastIdx));
        const x2 = toX(clamp(s.b.idx, winFirstIdx, winLastIdx));
        if (x1 != null && x2 != null) {
          const y1 = yOf(s.a.price), y2 = yOf(s.b.price);
          if (s.type === "line") {
            ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();
          } else {
            const left = Math.min(x1,x2);
            const top  = Math.min(y1,y2);
            const w = Math.abs(x2-x1);
            const h = Math.abs(y2-y1);
            ctx.strokeRect(left, top, w, h);
            if (s.type === "zone") {
              ctx.fillStyle = "rgba(100,181,255,0.06)";
              ctx.fillRect(left, top, w, h);
            }
          }
        }
      }
      ctx.setLineDash([]);
    }
  }

  function drawLabels(pr){
    ctx.fillStyle = "rgba(159,176,195,0.85)";
    ctx.font = "12px " + getComputedStyle(document.body).fontFamily;
    ctx.fillText(`max ${pr.max.toFixed(2)}`, 10, 16);
    ctx.fillText(`min ${pr.min.toFixed(2)}`, 10, canvas.height - 10);

    const yLast = (canvas.height - ((state.price - pr.min) / (pr.max - pr.min)) * canvas.height);
    ctx.fillStyle = "rgba(100,181,255,0.95)";
    ctx.beginPath();
    ctx.arc(canvas.width-10, yLast, 4, 0, Math.PI*2);
    ctx.fill();
  }

  function drawChart() {
    const w = canvas.width, h = canvas.height;
    ctx.clearRect(0,0,w,h);

    drawGrid(w,h);

    const win = getWindowBars();
    const windowBars = win.bars;

    if (windowBars.length < 2) return;

    const pr = computePriceRange(windowBars);
    const tf = makeTransform(windowBars, win.startPos, win.endPos, pr, w, h);

    drawCandles(windowBars, tf, w, h);
    drawShapes(tf, windowBars);
    drawLimits(tf, w);
    drawLabels(pr);

    // show window indices
    const firstIdx = windowBars[0].idx;
    const lastIdx = windowBars[windowBars.length-1].idx;
    $("stWin").textContent = `${firstIdx} ‚Üí ${lastIdx} (offset ${state.rightOffset})`;
  }

  // hit test shapes (simple)
  function distPointToSegment(px,py, x1,y1, x2,y2){
    const dx = x2-x1, dy = y2-y1;
    if (dx === 0 && dy === 0) return Math.hypot(px-x1, py-y1);
    const t = ((px-x1)*dx + (py-y1)*dy) / (dx*dx + dy*dy);
    const tt = clamp(t, 0, 1);
    const cx = x1 + tt*dx, cy = y1 + tt*dy;
    return Math.hypot(px-cx, py-cy);
  }

  function pickShapeAt(x,y){
    const win = getWindowBars();
    const windowBars = win.bars;
    if (windowBars.length < 2) return null;

    const pr = computePriceRange(windowBars);
    const tf = makeTransform(windowBars, win.startPos, win.endPos, pr, canvas.width, canvas.height);

    const winFirstIdx = windowBars[0].idx;
    const winLastIdx  = windowBars[windowBars.length-1].idx;

    const yOf = tf.yOf;
    const xOf = (idx) => {
      const i = idx - winFirstIdx;
      if (i < 0 || i >= windowBars.length) return null;
      return tf.xOfIndexInWindow(i);
    };

    // iterate reversed so "topmost" last drawn gets priority
    for (let i = state.shapes.length - 1; i >= 0; i--) {
      const s = state.shapes[i];
      if (s.type === "hline" && s.a) {
        const yy = yOf(s.a.price);
        if (Math.abs(y - yy) < 6) return s.id;
      } else if (s.type === "vline" && s.a && inWindowIdx(s.a.idx, winFirstIdx, winLastIdx)) {
        const xx = xOf(s.a.idx);
        if (xx != null && Math.abs(x - xx) < 6) return s.id;
      } else if (s.a && s.b) {
        const aIdx = clamp(s.a.idx, winFirstIdx, winLastIdx);
        const bIdx = clamp(s.b.idx, winFirstIdx, winLastIdx);
        const x1 = xOf(aIdx), x2 = xOf(bIdx);
        if (x1 == null || x2 == null) continue;
        const y1 = yOf(s.a.price), y2 = yOf(s.b.price);

        if (s.type === "line") {
          const d = distPointToSegment(x,y, x1,y1, x2,y2);
          if (d < 7) return s.id;
        } else if (s.type === "box" || s.type === "zone") {
          const left = Math.min(x1,x2), right = Math.max(x1,x2);
          const top = Math.min(y1,y2), bottom = Math.max(y1,y2);
          // near border or inside (zone)
          const inside = (x >= left && x <= right && y >= top && y <= bottom);
          const nearBorder =
            (Math.abs(x-left)<6 || Math.abs(x-right)<6) && y>=top-6 && y<=bottom+6 ||
            (Math.abs(y-top)<6 || Math.abs(y-bottom)<6) && x>=left-6 && x<=right+6;
          if (nearBorder || (inside && s.type === "zone")) return s.id;
        }
      }
    }
    return null;
  }

  function canvasToChartPoint(clientX, clientY){
    const rect = canvas.getBoundingClientRect();
    const x = (clientX - rect.left) * (canvas.width / rect.width);
    const y = (clientY - rect.top) * (canvas.height / rect.height);

    const win = getWindowBars();
    const windowBars = win.bars;
    if (windowBars.length < 2) return {x,y, idx:null, price:null};

    const pr = computePriceRange(windowBars);
    const tf = makeTransform(windowBars, win.startPos, win.endPos, pr, canvas.width, canvas.height);

    const i = tf.idxAtX(x);
    const idx = windowBars[i].idx;
    const price = roundTo(tf.priceOfY(y), state.tickSize);
    return {x,y, idx, price, tf, windowBars, pr};
  }

  // ===== UI: stats + orders
  function renderOrdersTable() {
    const body = $("ordersBody");
    body.innerHTML = "";
    const orders = [...state.limits].sort((a,b) => a.price - b.price);

    for (const o of orders) {
      const tr = document.createElement("tr");
      tr.style.cursor = "pointer";
      tr.title = "–ù–∞–∂–º–∏ —á—Ç–æ–±—ã –æ—Ç–º–µ–Ω–∏—Ç—å";
      tr.addEventListener("click", () => { cancelOrder(o.id); });

      const sideTag = o.side === "buy"
        ? `<span class="tag buy">BUY</span>`
        : `<span class="tag sell">SELL</span>`;

      tr.innerHTML = `
        <td>${sideTag}</td>
        <td>${o.price.toFixed(2)}</td>
        <td>${o.qty}</td>
        <td>${o.left}</td>
        <td>${o.id}</td>
      `;
      body.appendChild(tr);
    }
  }

  function renderStats() {
    const { bid, ask } = getBidAsk();
    $("hdrPrice").textContent = state.price.toFixed(2);
    $("hdrPos").textContent = String(state.pos);
    $("hdrFlow").textContent = state.flow.toFixed(2);

    $("stLast").textContent = state.price.toFixed(2);
    $("stBA").textContent = `${bid.toFixed(2)} / ${ask.toFixed(2)}`;
    $("stPos").textContent = String(state.pos);
    $("stAvg").textContent = state.avg == null ? "‚Äî" : state.avg.toFixed(2);
    $("stFlow").textContent = state.flow.toFixed(2);
  }

  function syncTopFromLeft() {
    if (document.activeElement !== $("qtyTop")) $("qtyTop").value = $("qty").value;
    if (document.activeElement !== $("slipTop")) $("slipTop").value = $("slip").value;
  }
  function syncLeftFromTop() {
    $("qty").value = String(Math.max(1, Math.floor(Number($("qtyTop").value || 1))));
    $("slip").value = String(Math.max(0, Math.floor(Number($("slipTop").value || 0))));
  }
  function getQty() {
    const q = Number($("qtyTop").value || $("qty").value || 1);
    return Math.max(1, Math.floor(q));
  }
  function getSlip() {
    const s = Number($("slipTop").value || $("slip").value || 0);
    return Math.max(0, Math.floor(s));
  }

  function applySettingsFromUI() {
    state.tickSize = Number($("tick").value) || 0.25;
    state.spreadTicks = Math.max(0, Number($("spread").value || 0));
    state.volatility = clamp(Number($("vol").value || 8), 1, 20);
    state.liquidity = clamp(Number($("liq").value || 10), 1, 20);
    state.impact = clamp(Number($("impact").value || 8), 0, 20);
    state.simHz = clamp(Number($("simHz").value || 60), 5, 120);

    state.visibleBars = clamp(Number($("visibleBars").value || 140), 20, 600);

    const tf = $("timeframe").value;
    state.barTicks = timeframeToBarTicks(tf, state.simHz);

    state.follow = $("follow").checked;

    syncTopFromLeft();
  }

  // ===== Tool actions
  function setTool(name){
    state.activeTool = name;
    $("tool").value = name;
    // cursor hint
    canvas.style.cursor = (name === "pan") ? "grab" : "crosshair";
  }

  function addShape(shape){
    shape.id = state.nextShapeId++;
    state.shapes.push(shape);
    state.selectedShapeId = shape.id;
  }

  function deleteSelectedShape(){
    if (state.selectedShapeId == null) return;
    const before = state.shapes.length;
    state.shapes = state.shapes.filter(s => s.id !== state.selectedShapeId);
    if (state.shapes.length !== before) {
      log(`üóëÔ∏è Deleted shape id=${state.selectedShapeId}`, "warn");
    }
    state.selectedShapeId = null;
  }

  function clearShapes(){
    const n = state.shapes.length;
    state.shapes = [];
    state.selectedShapeId = null;
    log(`üßΩ Cleared shapes (${n})`, "warn");
  }

  // ===== Pan/Zoom logic
  function clampOffset(){
    const all = getAllBarsForRender();
    const n = all.length;
    if (n <= 1) { state.rightOffset = 0; return; }
    const maxOffset = Math.max(0, n - 1); // can go all the way to first
    state.rightOffset = clamp(state.rightOffset, 0, maxOffset);
  }

  function zoomAt(focalIdx, direction){
    // direction: +1 zoom out, -1 zoom in
    const oldVis = state.visibleBars;
    const factor = (direction < 0) ? 0.85 : 1.18;
    const newVis = clamp(Math.round(oldVis * factor), 20, 600);
    if (newVis === oldVis) return;

    const win = getWindowBars();
    const bars = win.bars;
    if (!bars.length) { state.visibleBars = newVis; return; }

    const firstIdx = bars[0].idx;
    const lastIdx  = bars[bars.length-1].idx;

    // keep focalIdx at same relative position in window
    const rel = (focalIdx - firstIdx) / Math.max(1, (lastIdx - firstIdx));
    state.visibleBars = newVis;

    // recompute offset so that new window keeps focal
    const all = getAllBarsForRender();
    const n = all.length;
    const endIdx = lastIdx; // keep end for now
    const newStartTarget = Math.round(focalIdx - rel * (newVis - 1));
    const newEndTarget = newStartTarget + (newVis - 1);

    // translate target end into rightOffset against end of series
    // find position of newEndTarget in all bars; if not exact, clamp by idx range
    const allFirstIdx = all[0].idx;
    const allLastIdx = all[all.length-1].idx;
    const endIdxClamped = clamp(newEndTarget, allFirstIdx, allLastIdx);

    const offset = Math.max(0, allLastIdx - endIdxClamped);
    state.rightOffset = offset;

    // if user is zooming, stop follow (unless they explicitly re-enable)
    state.follow = $("follow").checked;
    if (state.follow) {
      // follow means always 0
      state.rightOffset = 0;
    }
    clampOffset();
  }

  function panByBars(deltaBars){
    // positive deltaBars => move window left (older) => increase offset
    state.rightOffset = Math.max(0, state.rightOffset + deltaBars);
    if (state.rightOffset > 0) {
      // user left the live edge
      $("follow").checked = false;
      state.follow = false;
    }
    clampOffset();
  }

  // ===== Canvas events (mouse)
  canvas.addEventListener("wheel", (e) => {
    e.preventDefault();
    applySettingsFromUI();

    const pt = canvasToChartPoint(e.clientX, e.clientY);
    const focalIdx = pt.idx ?? (getAllBarsForRender().slice(-1)[0]?.idx ?? 0);

    const dir = (e.deltaY > 0) ? +1 : -1;
    zoomAt(focalIdx, dir);
  }, { passive:false });

  canvas.addEventListener("mousedown", (e) => {
    applySettingsFromUI();
    const pt = canvasToChartPoint(e.clientX, e.clientY);
    if (pt.idx == null) return;

    state.dragging = true;
    const tool = state.activeTool;

    // Shift always forces pan
    const forcePan = e.shiftKey;

    if (tool === "pan" || forcePan) {
      state.dragMode = "pan";
      canvas.style.cursor = "grabbing";
      state.dragStart = { x: pt.x, y: pt.y, rightOffset: state.rightOffset };
      return;
    }

    if (tool === "select") {
      const picked = pickShapeAt(pt.x, pt.y);
      state.selectedShapeId = picked;
      // if nothing picked, keep null
      return;
    }

    // draw tools
    state.dragMode = "draw";
    state.dragStart = { idx: pt.idx, price: pt.price, x: pt.x, y: pt.y };

    if (tool === "hline") {
      state.tempShape = { type: "hline", a: { idx: pt.idx, price: pt.price }, b: null };
      // finalize immediately
      addShape({ type:"hline", a:{ idx: pt.idx, price: pt.price }, b:null });
      state.tempShape = null;
      state.dragging = false;
      state.dragMode = null;
      return;
    }
    if (tool === "vline") {
      state.tempShape = { type: "vline", a: { idx: pt.idx, price: pt.price }, b: null };
      addShape({ type:"vline", a:{ idx: pt.idx, price: pt.price }, b:null });
      state.tempShape = null;
      state.dragging = false;
      state.dragMode = null;
      return;
    }

    state.tempShape = { type: tool, a: { idx: pt.idx, price: pt.price }, b: { idx: pt.idx, price: pt.price } };
  });

  window.addEventListener("mousemove", (e) => {
    if (!state.dragging) return;
    applySettingsFromUI();

    const rect = canvas.getBoundingClientRect();
    const inside = e.clientX >= rect.left && e.clientX <= rect.right && e.clientY >= rect.top && e.clientY <= rect.bottom;
    if (!inside) return;

    const pt = canvasToChartPoint(e.clientX, e.clientY);
    if (pt.idx == null) return;

    if (state.dragMode === "pan" && state.dragStart) {
      // translate mouse dx into bars
      const win = getWindowBars();
      const windowBars = win.bars;
      if (windowBars.length < 2) return;

      const pr = computePriceRange(windowBars);
      const tf = makeTransform(windowBars, win.startPos, win.endPos, pr, canvas.width, canvas.height);

      const dx = pt.x - state.dragStart.x;
      const barsDelta = Math.round(-dx / tf.step); // dragging right shows older => increase offset
      state.rightOffset = Math.max(0, state.dragStart.rightOffset + barsDelta);

      if (state.rightOffset > 0) {
        $("follow").checked = false;
        state.follow = false;
      }
      clampOffset();
      return;
    }

    if (state.dragMode === "draw" && state.tempShape) {
      state.tempShape.b = { idx: pt.idx, price: pt.price };
      return;
    }
  });

  window.addEventListener("mouseup", (e) => {
    if (!state.dragging) return;
    const wasPan = (state.dragMode === "pan");
    state.dragging = false;
    state.dragMode = null;
    state.dragStart = null;
    if (wasPan) canvas.style.cursor = (state.activeTool === "pan") ? "grab" : "crosshair";

    if (state.tempShape) {
      const s = state.tempShape;
      // finalize shapes that need b
      if ((s.type === "line" || s.type === "box" || s.type === "zone") && s.a && s.b) {
        addShape({ type:s.type, a:s.a, b:s.b });
        log(`‚úèÔ∏è Added ${s.type.toUpperCase()} id=${state.selectedShapeId}`, "warn");
      }
      state.tempShape = null;
    }
  });

  // ===== UI wiring
  function buyMarket() { syncLeftFromTop(); marketOrder("buy", getQty(), getSlip()); }
  function sellMarket(){ syncLeftFromTop(); marketOrder("sell", getQty(), getSlip()); }

  $("buyMktTop").addEventListener("click", () => buyMarket());
  $("sellMktTop").addEventListener("click", () => sellMarket());

  $("qtyTop").addEventListener("input", syncLeftFromTop);
  $("slipTop").addEventListener("input", syncLeftFromTop);

  $("followWrap").addEventListener("click", (e) => {
    // allow clicking wrapper
    if (e.target.tagName !== "INPUT") $("follow").checked = !$("follow").checked;
    state.follow = $("follow").checked;
    if (state.follow) state.rightOffset = 0;
  });

  $("tool").addEventListener("change", () => {
    setTool($("tool").value);
  });

  $("delShape").addEventListener("click", () => deleteSelectedShape());
  $("clearShapes").addEventListener("click", () => clearShapes());

  $("placeLimit").addEventListener("click", () => {
    const side = $("limitSide").value;
    const qty = getQty();
    const price = Number($("limitPrice").value || 0);
    if (!Number.isFinite(price) || price <= 0) { log("‚ö†Ô∏è –í–≤–µ–¥–∏ —Ü–µ–Ω—É –ª–∏–º–∏—Ç–∫–∏ (> 0).", "warn"); return; }
    placeLimit(side, price, qty);
  });

  $("placeLadder").addEventListener("click", () => {
    const side = $("ladderSide").value;
    const levels = Math.max(1, Math.floor(Number($("ladderLevels").value || 1)));
    const step = Number($("ladderStep").value || state.tickSize);
    const qtyPer = Math.max(1, Math.floor(Number($("ladderQty").value || 1)));
    let start = Number($("ladderStart").value || 0);
    if (!Number.isFinite(start) || start <= 0) { start = state.price; $("ladderStart").value = start.toFixed(2); }
    placeLadder(side, start, levels, step, qtyPer);
  });

  $("cancelAll").addEventListener("click", () => cancelAll());
  $("flatten").addEventListener("click", () => flatten());

  $("shiftUp").addEventListener("click", () => { const pts = Number($("shiftPts").value||0); if (pts) shiftAll(Math.abs(pts)); });
  $("shiftDn").addEventListener("click", () => { const pts = Number($("shiftPts").value||0); if (pts) shiftAll(-Math.abs(pts)); });

  $("clearLog").addEventListener("click", () => $("log").innerHTML = "");

  $("pause").addEventListener("click", () => {
    state.paused = !state.paused;
    $("pause").textContent = state.paused ? "‚ñ∂Ô∏è Resume" : "‚è∏Ô∏è Pause";
    log(state.paused ? "‚è∏Ô∏è Market paused" : "‚ñ∂Ô∏è Market resumed", "warn");
  });

  $("reset").addEventListener("click", () => {
    state.price = 17000;
    state.velocity = 0;
    state.flow = 0;
    state.pos = 0;
    state.avg = null;
    state.limits = [];
    state.shapes = [];
    state.selectedShapeId = null;

    state.bars = [];
    state.lastBarIdx = 0;
    state._curBar = null;
    state._barCounter = 0;

    state.rightOffset = 0;
    $("follow").checked = true;
    state.follow = true;

    $("limitPrice").value = state.price.toFixed(2);
    $("ladderStart").value = state.price.toFixed(2);

    log("üîÅ Reset done", "warn");
  });

  // ===== Hotkeys
  window.addEventListener("keydown", (e) => {
    if (e.target && ["INPUT","SELECT"].includes(e.target.tagName)) return;

    if (e.key === " ") { e.preventDefault(); $("pause").click(); }
    if (e.key.toLowerCase() === "b") buyMarket();
    if (e.key.toLowerCase() === "s") sellMarket();
    if (e.key.toLowerCase() === "c") $("cancelAll").click();
    if (e.key.toLowerCase() === "f") $("flatten").click();
    if (e.key === "Delete" || e.key === "Backspace") deleteSelectedShape();

    // quick tool switches
    if (e.key.toLowerCase() === "p") setTool("pan");
    if (e.key.toLowerCase() === "l") setTool("line");
    if (e.key.toLowerCase() === "x") setTool("box");
    if (e.key.toLowerCase() === "z") setTool("zone");
    if (e.key.toLowerCase() === "h") setTool("hline");
    if (e.key.toLowerCase() === "v") setTool("vline");
    if (e.key.toLowerCase() === "e") setTool("select");
  });

  // ===== Main loop (rAF)
  let lastTs = performance.now();
  let acc = 0;

  function loop(ts) {
    const dt = (ts - lastTs) / 1000;
    lastTs = ts;

    applySettingsFromUI();

    const step = 1 / state.simHz;
    if (!state.paused) {
      acc += dt;
      acc = Math.min(acc, 0.25);
      while (acc >= step) {
        stepSimulationOnce();
        acc -= step;
      }
    }

    // follow
    if (state.follow) state.rightOffset = 0;
    clampOffset();

    renderStats();
    renderOrdersTable();
    drawChart();

    requestAnimationFrame(loop);
  }

  // init
  function init() {
    $("limitPrice").value = state.price.toFixed(2);
    $("ladderStart").value = state.price.toFixed(2);
    setTool("pan");
    log("–ì–æ—Ç–æ–≤–æ: –ø–∞–Ω/–∑—É–º + –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã. –ö–æ–ª–µ—Å–æ ‚Äî –∑—É–º, drag ‚Äî –ø–∞–Ω. üòà", "warn");
    requestAnimationFrame(loop);
  }

  // changes
  ["vol","liq","impact","simHz","tick","spread","timeframe","visibleBars","follow"].forEach(id => {
    $(id).addEventListener("change", () => {
      applySettingsFromUI();
      if (state.follow) state.rightOffset = 0;
    });
  });

  init();
})();
</script>
</body>
</html>
