<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Market Sandbox ‚Äî Clean</title>
  <style>
    :root{
      --bg:#070b10; --panel:#0d1320; --panel2:#0b111b;
      --text:#e7eef7; --muted:#9fb0c3; --line:#223044;
      --good:#3ddc97; --bad:#ff5b6e; --blue:#64b5ff; --warn:#ffcf5b;
      --shadow: 0 10px 30px rgba(0,0,0,.35);
      --radius: 14px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, "Noto Sans", "Liberation Sans", sans-serif;
    }
    *{box-sizing:border-box}
    body{
      margin:0; font-family:var(--sans); color:var(--text);
      background: radial-gradient(1200px 800px at 10% 10%, #0e1830 0%, var(--bg) 45%) fixed;
      overflow:hidden;
    }

    .topbar{
      position:fixed; inset:0 0 auto 0; height:64px;
      display:flex; align-items:center; gap:10px;
      padding:10px 12px;
      background: linear-gradient(180deg, rgba(13,19,32,.92), rgba(7,11,16,.70));
      border-bottom:1px solid rgba(34,48,68,.85);
      backdrop-filter: blur(10px);
      z-index:5;
    }
    .brand{
      display:flex; flex-direction:column; gap:2px; padding-right:8px;
      min-width: 220px;
    }
    .brand .t{font-weight:900; letter-spacing:.2px; font-size:14px;}
    .brand .s{color:var(--muted); font-size:12px; line-height:1.1}
    .chip{
      display:inline-flex; align-items:center; gap:8px;
      padding:8px 10px;
      border-radius:999px;
      border:1px solid rgba(34,48,68,.9);
      background: rgba(11,15,20,.45);
      box-shadow: var(--shadow);
      color:var(--muted);
      font-size:12px;
      white-space:nowrap;
      user-select:none;
    }
    .chip b{color:var(--text); font-weight:900; font-family:var(--mono)}
    .grow{flex:1}
    .row{display:flex; align-items:center; gap:8px; flex-wrap:wrap}

    .btn{
      border:none; cursor:pointer; user-select:none;
      padding:9px 12px; border-radius:12px;
      background: rgba(159,176,195,.10);
      border:1px solid rgba(159,176,195,.28);
      color:rgba(231,238,247,.96);
      font-weight:900; letter-spacing:.2px;
      transition: transform .06s ease, filter .15s ease;
      display:inline-flex; align-items:center; gap:8px;
      white-space:nowrap;
    }
    .btn:hover{filter:brightness(1.08)}
    .btn:active{transform:translateY(1px)}
    .btn.good{background: rgba(61,220,151,.16); border-color: rgba(61,220,151,.45); color:#bdf8de;}
    .btn.bad{background: rgba(255,91,110,.14); border-color: rgba(255,91,110,.45); color:#ffd0d7;}
    .btn.blue{background: rgba(100,181,255,.14); border-color: rgba(100,181,255,.50); color:#d4ebff;}
    .btn.warn{background: rgba(255,207,91,.12); border-color: rgba(255,207,91,.38); color:#ffe8b2;}
    .btn.small{padding:8px 10px; border-radius:11px; font-size:12px;}

    .field{
      display:inline-flex; align-items:center; gap:8px;
      padding:8px 10px;
      border-radius:12px;
      border:1px solid rgba(34,48,68,.85);
      background: rgba(11,15,20,.40);
      color:var(--muted);
      font-size:12px;
      user-select:none;
      white-space:nowrap;
    }
    .field input{
      width:72px;
      padding:7px 8px;
      border-radius:10px;
      border:1px solid rgba(34,48,68,.9);
      background: rgba(7,11,16,.55);
      color: var(--text);
      outline:none;
      font-family: var(--mono);
      font-size:12px;
    }
    .field input:focus{
      border-color: rgba(100,181,255,.55);
      box-shadow: 0 0 0 3px rgba(100,181,255,.12);
    }

    .speed{
      display:inline-flex; gap:6px; padding:6px;
      border-radius:12px;
      border:1px solid rgba(34,48,68,.85);
      background: rgba(11,15,20,.40);
    }
    .speed button{
      border:none; cursor:pointer;
      padding:7px 10px;
      border-radius:10px;
      background: rgba(159,176,195,.10);
      border:1px solid rgba(159,176,195,.25);
      color: rgba(231,238,247,.92);
      font-weight:900;
      font-size:12px;
    }
    .speed button.active{
      background: rgba(100,181,255,.16);
      border-color: rgba(100,181,255,.55);
      color: rgba(212,235,255,.98);
    }

    .stage{
      position:fixed;
      inset:64px 0 0 0;
      padding: 10px 12px 12px;
    }
    canvas{
      width:100%;
      height:100%;
      display:block;
      border-radius: 16px;
      border:1px solid rgba(34,48,68,.85);
      background: rgba(5,8,12,.72);
      box-shadow: var(--shadow);
      touch-action:none;
      cursor:grab;
    }

    .hintDock{
      position:fixed;
      left:12px;
      bottom:12px;
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      z-index:6;
    }
    .hint{
      padding:8px 10px;
      border-radius: 12px;
      border:1px solid rgba(34,48,68,.85);
      background: rgba(11,15,20,.45);
      color: var(--muted);
      font-size:12px;
      user-select:none;
      backdrop-filter: blur(8px);
    }
    .kbd{
      font-family: var(--mono);
      padding: 1px 6px;
      border-radius: 8px;
      border:1px solid rgba(34,48,68,.95);
      background: rgba(7,11,16,.65);
      color: rgba(231,238,247,.96);
      margin: 0 2px;
      white-space:nowrap;
    }

    .toast{
      position:fixed;
      right:12px;
      bottom:12px;
      width:min(520px, calc(100vw - 24px));
      max-height: 40vh;
      overflow:auto;
      border-radius: 16px;
      border:1px solid rgba(34,48,68,.85);
      background: rgba(11,15,20,.45);
      backdrop-filter: blur(10px);
      box-shadow: var(--shadow);
      font-family: var(--mono);
      font-size:12px;
      color: rgba(231,238,247,.92);
      padding:10px;
      z-index:7;
    }
    .toast .line{padding:4px 0; border-bottom:1px dashed rgba(34,48,68,.40);}
    .toast .line:last-child{border-bottom:none;}
    .g{color:#bdf8de}
    .r{color:#ffd0d7}
    .y{color:#ffe8b2}
  </style>
</head>
<body>

  <div class="topbar">
    <div class="brand">
      <div class="t">Market Sandbox ‚Äî Clean üìà</div>
      <div class="s">–ü–ª–∞–≤–Ω—ã–π pan/zoom, –Ω–µ –ø—É—Å—Ç–æ, –±–µ–∑ advanced. Ctrl+Click=Limit, Alt+Click=Cancel near.</div>
    </div>

    <div class="row">
      <button class="btn good" id="buyBtn" title="B">‚¨Ü Buy</button>
      <button class="btn bad" id="sellBtn" title="S">‚¨á Sell</button>

      <div class="field">qty <input id="qty" type="number" min="1" step="1" value="1"></div>
      <div class="field">slip <input id="slip" type="number" min="0" step="1" value="1"></div>

      <button class="btn warn" id="flattenBtn" title="X">üßØ Flatten</button>
      <button class="btn" id="cancelAllBtn" title="C">üßπ Cancel</button>
    </div>

    <div class="grow"></div>

    <div class="row">
      <button class="btn blue small" id="pauseBtn" title="Space">‚è∏ Pause</button>
      <button class="btn blue small" id="stepBtn" title="Step 1 tick (paused)">‚è≠ Step</button>

      <div class="speed" title="Speed: 1..5">
        <button class="active" data-sp="0.5">0.5x</button>
        <button data-sp="1">1x</button>
        <button data-sp="2">2x</button>
        <button data-sp="5">5x</button>
        <button data-sp="10">10x</button>
      </div>

      <button class="btn small" id="followBtn" title="F">üéØ Follow: ON</button>
      <button class="btn small" id="resetBtn" title="R">üîÅ Reset</button>

      <div class="chip">Last: <b id="hudLast">‚Äî</b></div>
      <div class="chip">Pos: <b id="hudPos">0</b></div>
      <div class="chip">uPnL: <b id="hudPnL">‚Äî</b></div>
      <div class="chip">Speed: <b id="hudSp">1.0x</b></div>
    </div>
  </div>

  <div class="stage">
    <canvas id="cv"></canvas>
  </div>

  <div class="hintDock">
    <div class="hint">
      Drag = pan ‚Ä¢ Wheel = zoom (–ø–æ –∫—É—Ä—Å–æ—Ä—É) ‚Ä¢ Shift+Wheel = —Å–∫—Ä–æ–ª–ª ‚Ä¢ DoubleClick = reset view
    </div>
    <div class="hint">
      <span class="kbd">B</span>/<span class="kbd">S</span> market ‚Ä¢ <span class="kbd">Space</span> pause ‚Ä¢ <span class="kbd">F</span> follow ‚Ä¢
      <span class="kbd">C</span> cancel ‚Ä¢ <span class="kbd">X</span> flatten ‚Ä¢ <span class="kbd">R</span> reset ‚Ä¢ <span class="kbd">1..5</span> speed
    </div>
    <div class="hint">
      <span class="kbd">Ctrl+LMB</span> Buy Limit ‚Ä¢ <span class="kbd">Ctrl+RMB</span> Sell Limit ‚Ä¢ <span class="kbd">Alt+Click</span> cancel nearest
    </div>
  </div>

  <div class="toast" id="log"></div>

<script>
(() => {
  const $ = (id) => document.getElementById(id);
  const cv = $("cv");
  const ctx = cv.getContext("2d", { alpha: true });

  const clamp = (x,a,b) => Math.max(a, Math.min(b, x));
  const roundTo = (x, step) => Math.round(x/step)*step;
  const now = () => new Date().toLocaleTimeString();

  const state = {
    // market
    tick: 0.25,
    spreadTicks: 1,
    vol: 8,
    liq: 10,
    impact: 8,

    baseHz: 60,
    speed: 1,
    paused: false,

    price: 17000,
    v: 0,
    flow: 0,
    flowDecay: 0.94,

    // position
    pos: 0,
    avg: null,

    // limits
    nextId: 1,
    limits: [],

    // candles
    barSeconds: 5,
    barTicks: 300,
    curBar: null,
    curTicks: 0,
    bars: [],

    // camera (TV-like)
    follow: true,
    barsPerScreen: 160,
    center: 0, // float bar index center

    // interaction
    dragging: false,
    dragStart: null,
    cross: { on:false, x:0, y:0, idx:null, price:null }
  };

  // ========= LOG
  function log(msg, cls="") {
    const el = $("log");
    const line = document.createElement("div");
    line.className = "line " + cls;
    line.textContent = `[${now()}] ${msg}`;
    el.prepend(line);
    // keep last 40
    while (el.children.length > 40) el.removeChild(el.lastChild);
  }

  // ========= MARKET HELPERS
  function simHz() { return clamp(state.baseHz * state.speed, 5, 600); }

  function bidAsk() {
    const spread = state.spreadTicks * state.tick;
    return { bid: state.price - spread/2, ask: state.price + spread/2 };
  }

  function upnl() {
    if (!state.pos || state.avg == null) return null;
    return (state.price - state.avg) * state.pos;
  }

  function applyFill(side, qty, fillPrice, reason) {
    const oldPos = state.pos;
    const newPos = oldPos + (side === "buy" ? qty : -qty);

    if (oldPos === 0) state.avg = fillPrice;
    else if (Math.sign(oldPos) === Math.sign(newPos) && newPos !== 0) {
      const oldAbs = Math.abs(oldPos), newAbs = Math.abs(newPos);
      const addQty = newAbs - oldAbs;
      if (addQty > 0) state.avg = (state.avg * oldAbs + fillPrice * addQty) / newAbs;
    } else if (newPos === 0) state.avg = null;
    else if (Math.sign(oldPos) !== Math.sign(newPos)) state.avg = fillPrice;

    state.pos = newPos;
    state.flow += (side === "buy" ? qty : -qty);

    log(`${side.toUpperCase()} ${qty} @ ${fillPrice.toFixed(2)} (${reason})`, side === "buy" ? "g" : "r");
  }

  function market(side, qty, slipTicks) {
    const { bid, ask } = bidAsk();
    const slip = slipTicks * state.tick;
    const fill = side === "buy" ? (ask + slip) : (bid - slip);
    applyFill(side, qty, fill, "MKT");
  }

  function placeLimit(side, price, qty) {
    price = roundTo(price, state.tick);
    const id = state.nextId++;
    state.limits.push({ id, side, price, qty, left: qty });
    log(`+ LIMIT ${side.toUpperCase()} ${qty} @ ${price.toFixed(2)} (id=${id})`, "y");
  }

  function cancelAll() {
    const n = state.limits.length;
    state.limits = [];
    log(`Cancel all (${n})`, "y");
  }

  function cancelNearest(price) {
    if (!state.limits.length) return false;
    let best = null;
    for (const o of state.limits) {
      const d = Math.abs(o.price - price);
      if (!best || d < best.d) best = { d, id: o.id, price: o.price };
    }
    const th = state.tick * 6;
    if (best && best.d <= th) {
      state.limits = state.limits.filter(o => o.id !== best.id);
      log(`Cancel id=${best.id} near ${best.price.toFixed(2)}`, "y");
      return true;
    }
    return false;
  }

  function flatten() {
    if (state.pos === 0) { log("Flatten: pos already 0", "y"); return; }
    const qty = Math.abs(state.pos);
    const side = state.pos > 0 ? "sell" : "buy";
    market(side, qty, getSlip());
    log("Flatten done", "y");
  }

  // ========= CANDLES
  function timeframeTicks() {
    return Math.max(2, Math.round(state.barSeconds * simHz()));
  }

  function ensureBar() {
    if (!state.curBar) {
      state.curBar = { o: state.price, h: state.price, l: state.price, c: state.price };
      state.curTicks = 0;
    }
  }

  function pushTickToBar(p) {
    ensureBar();
    state.curBar.h = Math.max(state.curBar.h, p);
    state.curBar.l = Math.min(state.curBar.l, p);
    state.curBar.c = p;

    state.curTicks++;
    const bt = timeframeTicks();
    if (state.curTicks >= bt) {
      state.bars.push(state.curBar);
      if (state.bars.length > 6000) state.bars.shift();
      state.curBar = { o: p, h: p, l: p, c: p };
      state.curTicks = 0;

      if (state.follow) state.center = state.bars.length - 1;
    }
  }

  function matchLimits() {
    const { bid, ask } = bidAsk();
    const liq = clamp(state.liq, 1, 20);

    const filled = [];
    for (const o of state.limits) {
      const canFill = (o.side === "buy") ? (ask <= o.price) : (bid >= o.price);
      if (!canFill || o.left <= 0) continue;

      // chunking: lower liquidity fills larger chunks (sandbox style)
      const baseChunk = Math.max(1, Math.round(o.qty * (21 - liq) / 20));
      const chunk = Math.min(o.left, baseChunk);

      o.left -= chunk;
      applyFill(o.side, chunk, o.price, `LMT id=${o.id}`);
      if (o.left <= 0) filled.push(o.id);
    }
    if (filled.length) state.limits = state.limits.filter(o => !filled.includes(o.id));
  }

  // ========= SIMULATION STEP
  function stepOnce() {
    state.flow *= state.flowDecay;

    const vol = clamp(state.vol, 1, 20);
    const r = (Math.random()+Math.random()+Math.random()+Math.random()-2);
    const noise = r * (vol * state.tick * 0.18);

    const imp = clamp(state.impact, 0, 20);
    const liq = clamp(state.liq, 1, 20);
    const pressure = state.flow * (imp * state.tick * 0.045) * (1 / (liq * 0.40));

    state.v = (state.v * 0.92) + noise + pressure;
    state.price = roundTo(state.price + state.v, state.tick);

    pushTickToBar(state.price);
    matchLimits();
  }

  // ========= CAMERA / MAPPING
  function barsAll() {
    const arr = state.bars.slice();
    if (state.curBar) arr.push(state.curBar);
    return arr;
  }

  function getWindow(n) {
    if (n <= 1) return { start:0, end:0 };
    const bps = clamp(state.barsPerScreen, 30, 800);
    const half = (bps - 1) / 2;

    let center = state.center;
    center = clamp(center, 0, n - 1);

    let start = center - half;
    let end   = center + half;

    if (start < 0) { end -= start; start = 0; }
    if (end > n - 1) { start -= (end - (n - 1)); end = n - 1; }
    start = clamp(start, 0, n - 1);
    end = clamp(end, 0, n - 1);

    return { start, end, bps };
  }

  // ========= CANVAS RESIZE (HiDPI)
  function resize() {
    const r = cv.getBoundingClientRect();
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    const w = Math.round(r.width * dpr);
    const h = Math.round(r.height * dpr);
    if (cv.width !== w || cv.height !== h) {
      cv.width = w; cv.height = h;
      ctx.setTransform(dpr,0,0,dpr,0,0); // draw in css pixels
    }
  }
  window.addEventListener("resize", resize);

  // ========= RENDER
  function niceStep(range, target=8) {
    const raw = range / target;
    const pow = Math.pow(10, Math.floor(Math.log10(raw)));
    const frac = raw / pow;
    let nice;
    if (frac <= 1) nice = 1;
    else if (frac <= 2) nice = 2;
    else if (frac <= 5) nice = 5;
    else nice = 10;
    return nice * pow;
  }

  function draw() {
    resize();

    const r = cv.getBoundingClientRect();
    const W = r.width, H = r.height;

    ctx.clearRect(0,0,W,H);

    const leftPad = 76, rightPad = 16, topPad = 12, bottomPad = 28;
    const x0 = leftPad, x1 = W - rightPad, y0 = topPad, y1 = H - bottomPad;
    const plotW = x1 - x0, plotH = y1 - y0;

    // background panels
    ctx.fillStyle = "rgba(5,8,12,0.35)";
    ctx.fillRect(x0, y0, plotW, plotH);
    ctx.fillStyle = "rgba(11,15,20,0.50)";
    ctx.fillRect(0, 0, leftPad, H);

    // frame line
    ctx.strokeStyle = "rgba(34,48,68,0.9)";
    ctx.lineWidth = 1;
    ctx.beginPath(); ctx.moveTo(leftPad+0.5,0); ctx.lineTo(leftPad+0.5,H); ctx.stroke();

    const all = barsAll();
    const n = all.length;
    if (n < 2) return;

    // follow logic
    if (state.follow) state.center = n - 1;

    const win = getWindow(n);
    const start = win.start, end = win.end;
    const span = Math.max(1e-9, end - start);

    // visible bars slice
    const i0 = Math.floor(start);
    const i1 = Math.ceil(end);
    const vis = all.slice(i0, i1 + 1);

    // price range
    let pmin = Infinity, pmax = -Infinity;
    for (const b of vis) { pmin = Math.min(pmin, b.l); pmax = Math.max(pmax, b.h); }
    for (const o of state.limits) { pmin = Math.min(pmin, o.price); pmax = Math.max(pmax, o.price); }
    pmin = Math.min(pmin, state.price);
    pmax = Math.max(pmax, state.price);
    if (!Number.isFinite(pmin) || !Number.isFinite(pmax) || pmin === pmax) {
      pmin = state.price - 50*state.tick;
      pmax = state.price + 50*state.tick;
    }
    const pad = (pmax - pmin) * 0.12 + state.tick * 20;
    pmin -= pad; pmax += pad;

    const yOf = (p) => y1 - ((p - pmin)/(pmax - pmin)) * plotH;
    const xOf = (idx) => x0 + ((idx - start)/span) * plotW;

    // grid + labels
    ctx.font = `12px ${getComputedStyle(document.body).fontFamily}`;
    ctx.textBaseline = "middle";

    let step = niceStep(pmax - pmin, 8);
    step = Math.max(state.tick, roundTo(step, state.tick));
    const first = Math.floor(pmin / step) * step;

    for (let p = first; p <= pmax + step; p += step) {
      const pp = roundTo(p, state.tick);
      const y = yOf(pp);

      ctx.strokeStyle = "rgba(34,48,68,0.42)";
      ctx.lineWidth = 1;
      ctx.beginPath(); ctx.moveTo(x0,y); ctx.lineTo(x1,y); ctx.stroke();

      ctx.fillStyle = "rgba(159,176,195,0.95)";
      ctx.fillText(pp.toFixed(2), 8, y);
    }

    // vertical guides
    const vSteps = 10;
    for (let k=1;k<vSteps;k++){
      const x = x0 + (k/vSteps)*plotW;
      ctx.strokeStyle = "rgba(34,48,68,0.30)";
      ctx.beginPath(); ctx.moveTo(x,y0); ctx.lineTo(x,y1); ctx.stroke();
    }

    // candles (dynamic width)
    const barsPerScreen = win.bps;
    const candleW = clamp(Math.floor(plotW / (barsPerScreen + 8)), 3, 16);
    const gap = clamp(Math.floor(candleW*0.35), 1, 6);

    // draw only integer bars inside range
    const j0 = Math.max(0, Math.floor(start) - 2);
    const j1 = Math.min(n-1, Math.ceil(end) + 2);
    for (let i=j0;i<=j1;i++){
      const b = all[i];
      const xMid = xOf(i);
      const x = xMid - candleW/2;

      const yO = yOf(b.o), yH = yOf(b.h), yL = yOf(b.l), yC = yOf(b.c);
      const up = b.c >= b.o;

      ctx.strokeStyle = up ? "rgba(61,220,151,0.85)" : "rgba(255,91,110,0.85)";
      ctx.lineWidth = 1.4;
      ctx.beginPath(); ctx.moveTo(xMid, yH); ctx.lineTo(xMid, yL); ctx.stroke();

      const top = Math.min(yO,yC);
      const h = Math.max(2, Math.abs(yC - yO));
      ctx.fillStyle = up ? "rgba(61,220,151,0.28)" : "rgba(255,91,110,0.26)";
      ctx.strokeStyle = up ? "rgba(61,220,151,0.95)" : "rgba(255,91,110,0.95)";
      ctx.fillRect(x, top, candleW, h);
      ctx.strokeRect(x, top, candleW, h);
    }

    // bid/ask band
    const {bid, ask} = bidAsk();
    const yB = yOf(bid), yA = yOf(ask);
    ctx.fillStyle = "rgba(159,176,195,0.08)";
    ctx.fillRect(x0, Math.min(yB,yA), plotW, Math.abs(yB-yA));

    // limits
    for (const o of state.limits) {
      const y = yOf(o.price);
      ctx.strokeStyle = o.side === "buy" ? "rgba(61,220,151,0.65)" : "rgba(255,91,110,0.65)";
      ctx.lineWidth = 1.4;
      ctx.beginPath(); ctx.moveTo(x0,y); ctx.lineTo(x1,y); ctx.stroke();

      ctx.fillStyle = o.side === "buy" ? "rgba(61,220,151,0.95)" : "rgba(255,91,110,0.95)";
      ctx.fillText(`${o.side.toUpperCase()} ${o.price.toFixed(2)} (left ${o.left})`, x0+10, y-10);
    }

    // avg line (if position)
    if (state.pos !== 0 && state.avg != null) {
      const y = yOf(state.avg);
      ctx.strokeStyle = "rgba(255,207,91,0.55)";
      ctx.lineWidth = 1.2;
      ctx.setLineDash([6,6]);
      ctx.beginPath(); ctx.moveTo(x0,y); ctx.lineTo(x1,y); ctx.stroke();
      ctx.setLineDash([]);
      ctx.fillStyle = "rgba(255,207,91,0.95)";
      ctx.fillText(`AVG ${state.avg.toFixed(2)}`, x0+10, y+12);
    }

    // last price label
    const yLast = yOf(state.price);
    ctx.fillStyle = "rgba(100,181,255,0.18)";
    ctx.fillRect(0, yLast-12, leftPad, 24);
    ctx.strokeStyle = "rgba(100,181,255,0.65)";
    ctx.strokeRect(0.5, yLast-11.5, leftPad-1, 23);
    ctx.fillStyle = "rgba(212,235,255,0.98)";
    ctx.fillText(state.price.toFixed(2), 8, yLast);

    // crosshair
    if (state.cross.on) {
      const cx = clamp(state.cross.x, x0, x1);
      const cy = clamp(state.cross.y, y0, y1);

      ctx.strokeStyle = "rgba(159,176,195,0.55)";
      ctx.lineWidth = 1;
      ctx.setLineDash([4,4]);
      ctx.beginPath(); ctx.moveTo(x0,cy); ctx.lineTo(x1,cy); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(cx,y0); ctx.lineTo(cx,y1); ctx.stroke();
      ctx.setLineDash([]);

      const cp = state.cross.price;
      if (cp != null) {
        ctx.fillStyle = "rgba(159,176,195,0.14)";
        ctx.fillRect(0, cy-12, leftPad, 24);
        ctx.strokeStyle = "rgba(159,176,195,0.55)";
        ctx.strokeRect(0.5, cy-11.5, leftPad-1, 23);
        ctx.fillStyle = "rgba(231,238,247,0.98)";
        ctx.fillText(cp.toFixed(2), 8, cy);
      }
    }

    // bottom index label (simple)
    ctx.fillStyle = "rgba(159,176,195,0.85)";
    ctx.textBaseline = "alphabetic";
    ctx.fillText(`bars: ${n} | view: ${Math.floor(start)} ‚Üí ${Math.floor(end)}`, x0, H-10);
  }

  // ========= UI
  function getQty(){ return Math.max(1, Math.floor(Number($("qty").value || 1))); }
  function getSlip(){ return Math.max(0, Math.floor(Number($("slip").value || 0))); }

  function updateHUD() {
    $("hudLast").textContent = state.price.toFixed(2);
    $("hudPos").textContent = String(state.pos);
    const p = upnl();
    $("hudPnL").textContent = p == null ? "‚Äî" : p.toFixed(2);
    $("hudSp").textContent = state.speed.toFixed(1) + "x";
    $("followBtn").textContent = state.follow ? "üéØ Follow: ON" : "üéØ Follow: OFF";
    $("pauseBtn").textContent = state.paused ? "‚ñ∂ Resume" : "‚è∏ Pause";
  }

  // ========= INTERACTION (PAN/ZOOM THAT ACTUALLY FEELS NORMAL)
  function clientToCanvas(e) {
    const r = cv.getBoundingClientRect();
    return { x: e.clientX - r.left, y: e.clientY - r.top, w: r.width, h: r.height };
  }

  function crossFromPoint(pt) {
    const r = cv.getBoundingClientRect();
    const W = r.width, H = r.height;

    const leftPad = 76, rightPad = 16, topPad = 12, bottomPad = 28;
    const x0 = leftPad, x1 = W - rightPad, y0 = topPad, y1 = H - bottomPad;
    const plotW = x1 - x0;

    const all = barsAll();
    const n = all.length;
    if (n < 2) return;

    const win = getWindow(n);
    const start = win.start, end = win.end;
    const span = Math.max(1e-9, end - start);

    const xClamped = clamp(pt.x, x0, x1);
    const frac = (xClamped - x0) / plotW;
    const idxFloat = start + frac * span;
    const idx = Math.round(idxFloat);

    // price is from current visible range (approx, good enough for limits)
    // we recompute from visible bars (fast enough)
    const i0 = Math.floor(start), i1 = Math.ceil(end);
    const vis = all.slice(Math.max(0,i0), Math.min(n-1,i1) + 1);
    let pmin = Infinity, pmax = -Infinity;
    for (const b of vis) { pmin = Math.min(pmin, b.l); pmax = Math.max(pmax, b.h); }
    for (const o of state.limits) { pmin = Math.min(pmin, o.price); pmax = Math.max(pmax, o.price); }
    pmin = Math.min(pmin, state.price);
    pmax = Math.max(pmax, state.price);
    if (!Number.isFinite(pmin) || !Number.isFinite(pmax) || pmin === pmax) { pmin = state.price-50*state.tick; pmax = state.price+50*state.tick; }
    const pad = (pmax - pmin) * 0.12 + state.tick * 20;
    pmin -= pad; pmax += pad;

    const cy = clamp(pt.y, y0, y1);
    const t = (y1 - cy) / (y1 - y0);
    const price = roundTo(pmin + t * (pmax - pmin), state.tick);

    state.cross.on = true;
    state.cross.x = pt.x;
    state.cross.y = pt.y;
    state.cross.idx = clamp(idx, 0, n-1);
    state.cross.price = price;
  }

  cv.addEventListener("pointerdown", (e) => {
    cv.setPointerCapture(e.pointerId);
    state.dragging = true;
    const pt = clientToCanvas(e);

    // any manual interaction turns follow off (TV behavior)
    state.follow = false;

    state.dragStart = {
      x: pt.x,
      center: state.center
    };
    cv.style.cursor = "grabbing";
    crossFromPoint(pt);
  });

  cv.addEventListener("pointermove", (e) => {
    const pt = clientToCanvas(e);
    crossFromPoint(pt);

    if (!state.dragging || !state.dragStart) return;

    const r = cv.getBoundingClientRect();
    const W = r.width;

    const leftPad = 76, rightPad = 16;
    const plotW = (W - rightPad) - leftPad;
    if (plotW <= 50) return;

    const all = barsAll();
    const n = all.length;
    const win = getWindow(n);
    const spanBars = Math.max(1, win.bps - 1);

    const dx = pt.x - state.dragStart.x;
    const deltaBars = -dx / plotW * spanBars;

    state.center = state.dragStart.center + deltaBars;
    state.center = clamp(state.center, 0, Math.max(0, n-1));
  });

  function pointerUp() {
    state.dragging = false;
    state.dragStart = null;
    cv.style.cursor = "grab";
  }
  cv.addEventListener("pointerup", pointerUp);
  cv.addEventListener("pointercancel", pointerUp);

  // wheel zoom (ANCHOR TO CURSOR) + shift wheel pan
  cv.addEventListener("wheel", (e) => {
    e.preventDefault();

    const pt = clientToCanvas(e);
    const r = cv.getBoundingClientRect();
    const W = r.width;

    const leftPad = 76, rightPad = 16;
    const x0 = leftPad, x1 = W - rightPad;
    const plotW = x1 - x0;

    const all = barsAll();
    const n = all.length;
    if (n < 2) return;

    // Shift+wheel = horizontal scroll (fast)
    if (e.shiftKey) {
      state.follow = false;
      const dir = e.deltaY > 0 ? +1 : -1;
      state.center += dir * (state.barsPerScreen * 0.10);
      state.center = clamp(state.center, 0, n-1);
      return;
    }

    // zoom x
    const win = getWindow(n);
    const start = win.start, end = win.end;
    const span = Math.max(1e-9, end - start);

    const xClamped = clamp(pt.x, x0, x1);
    const frac = (xClamped - x0) / plotW;
    const anchor = start + frac * span;

    const zoomIn = e.deltaY < 0;
    const factor = zoomIn ? 0.85 : 1.18;

    const old = state.barsPerScreen;
    let neu = Math.round(old * factor);
    neu = clamp(neu, 30, 800);
    if (neu === old) return;

    state.follow = false;
    state.barsPerScreen = neu;

    // keep anchor under cursor
    const newSpan = (neu - 1);
    const newStart = anchor - frac * newSpan;
    state.center = newStart + newSpan/2;

    state.center = clamp(state.center, 0, n-1);
  }, { passive:false });

  // double click = reset view
  cv.addEventListener("dblclick", () => {
    state.barsPerScreen = 160;
    state.follow = true;
    state.center = Math.max(0, barsAll().length - 1);
    log("View reset (follow ON)", "y");
  });

  // right-click menu off (we use ctrl+RMB)
  cv.addEventListener("contextmenu", (e) => e.preventDefault());

  // Ctrl/Alt clicks for limits
  cv.addEventListener("pointerup", (e) => {
    // detect tap (not drag)
    const pt = clientToCanvas(e);
    const moved = state.dragStart ? Math.abs(pt.x - state.dragStart.x) : 999;
    // if it was a drag, ignore quick actions
    if (moved > 7) return;

    crossFromPoint(pt);
    const p = state.cross.price;
    if (p == null) return;

    if (e.altKey) {
      const ok = cancelNearest(p);
      if (!ok) log("No limit near that price (Alt+Click)", "y");
      return;
    }
    if (e.ctrlKey) {
      const side = (e.button === 2) ? "sell" : "buy";
      placeLimit(side, p, getQty());
    }
  });

  // ========= BUTTONS
  $("buyBtn").addEventListener("click", () => market("buy", getQty(), getSlip()));
  $("sellBtn").addEventListener("click", () => market("sell", getQty(), getSlip()));
  $("cancelAllBtn").addEventListener("click", cancelAll);
  $("flattenBtn").addEventListener("click", flatten);

  $("pauseBtn").addEventListener("click", () => {
    state.paused = !state.paused;
    log(state.paused ? "Paused" : "Resumed", "y");
  });

  $("stepBtn").addEventListener("click", () => {
    if (!state.paused) { log("Step works only when paused", "y"); return; }
    stepOnce();
  });

  $("followBtn").addEventListener("click", () => {
    state.follow = !state.follow;
    if (state.follow) state.center = Math.max(0, barsAll().length - 1);
    log(`Follow ${state.follow ? "ON" : "OFF"}`, "y");
  });

  $("resetBtn").addEventListener("click", resetAll);

  // speed buttons
  document.querySelectorAll(".speed button").forEach(btn => {
    btn.addEventListener("click", () => {
      const v = Number(btn.dataset.sp);
      state.speed = clamp(v, 0.1, 50);
      document.querySelectorAll(".speed button").forEach(b => b.classList.toggle("active", b === btn));
      log(`Speed = ${state.speed}x`, "y");
    });
  });

  // ========= HOTKEYS
  window.addEventListener("keydown", (e) => {
    const tag = (document.activeElement && document.activeElement.tagName) || "";
    const typing = tag === "INPUT" || tag === "TEXTAREA" || tag === "SELECT";
    if (typing) return;

    const k = e.key.toLowerCase();
    if (k === "b") market("buy", getQty(), getSlip());
    if (k === "s") market("sell", getQty(), getSlip());
    if (k === "c") cancelAll();
    if (k === "x") flatten();
    if (k === "f") {
      state.follow = !state.follow;
      if (state.follow) state.center = Math.max(0, barsAll().length - 1);
      log(`Follow ${state.follow ? "ON" : "OFF"}`, "y");
    }
    if (k === "r") resetAll();
    if (k === " ") { e.preventDefault(); $("pauseBtn").click(); }

    // speed 1..5 = 0.5/1/2/5/10
    if (k === "1") setSpeedBtn("0.5");
    if (k === "2") setSpeedBtn("1");
    if (k === "3") setSpeedBtn("2");
    if (k === "4") setSpeedBtn("5");
    if (k === "5") setSpeedBtn("10");
  });

  function setSpeedBtn(val) {
    const btn = [...document.querySelectorAll(".speed button")].find(b => b.dataset.sp === val);
    if (btn) btn.click();
  }

  // ========= PRESEED (NO EMPTY CHART)
  function preseedHistory(barCount = 900) {
    // generate quickly: simulate ticks until we have barCount bars
    state.bars = [];
    state.curBar = null;
    state.curTicks = 0;

    // start price with slight randomness so it doesn't look "flat"
    state.price = roundTo(17000 + (Math.random()-0.5)*200, state.tick);
    state.v = 0;
    state.flow = 0;

    // ensure speed=1 for consistent seeding
    const oldSpeed = state.speed;
    state.speed = 1;

    // we want N bars, each bar is barSeconds * hz ticks
    const targetBars = barCount;
    const maxTicks = targetBars * Math.round(state.barSeconds * state.baseHz);

    for (let i=0; i<maxTicks; i++) stepOnce();

    // set camera to latest
    state.follow = true;
    state.center = Math.max(0, barsAll().length - 1);

    state.speed = oldSpeed;
  }

  // ========= RESET
  function resetAll() {
    state.pos = 0;
    state.avg = null;
    state.limits = [];
    state.nextId = 1;

    state.vol = 8; state.liq = 10; state.impact = 8;
    state.spreadTicks = 1;

    state.barsPerScreen = 160;
    state.follow = true;

    preseedHistory(900);
    log("Reset done (history regenerated)", "y");
  }

  // ========= MAIN LOOP
  let last = performance.now();
  let acc = 0;

  function frame(ts) {
    const dt = Math.min(0.05, (ts - last) / 1000);
    last = ts;

    const hz = simHz();
    const step = 1 / hz;

    if (!state.paused) {
      acc += dt;
      acc = Math.min(acc, 0.25);
      while (acc >= step) {
        stepOnce();
        acc -= step;
      }
    }

    updateHUD();
    draw();

    requestAnimationFrame(frame);
  }

  // init
  function init() {
    preseedHistory(900);
    updateHUD();
    log("Ready. Drag/Wheel works –Ω–æ—Ä–º–∞–ª—å–Ω–æ. Chart not empty ‚úÖ", "y");
    requestAnimationFrame(frame);
  }

  init();
})();
</script>
</body>
</html>
