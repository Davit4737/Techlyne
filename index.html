<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Market Sandbox ‚Äî TV-like Chart (New Engine)</title>
  <style>
    :root{
      --bg:#0b0f14; --text:#e7eef7; --muted:#9fb0c3; --line:#223044;
      --shadow: 0 10px 30px rgba(0,0,0,.35); --radius: 14px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, "Noto Sans", "Liberation Sans", sans-serif;
    }
    *{box-sizing:border-box}
    body{
      margin:0; font-family:var(--sans);
      background: radial-gradient(1200px 800px at 10% 10%, #101a2a 0%, var(--bg) 45%) fixed;
      color:var(--text);
    }

    header{
      padding:12px 16px;
      border-bottom:1px solid var(--line);
      background: linear-gradient(180deg, rgba(17,24,36,.88), rgba(11,15,20,.58));
      position:sticky; top:0; z-index:4;
      backdrop-filter: blur(8px);
    }
    header .row{
      display:flex; align-items:center; justify-content:space-between; gap:12px;
      max-width:1480px; margin:0 auto;
      flex-wrap:wrap;
    }
    .title{display:flex; flex-direction:column; gap:2px;}
    .title h1{font-size:16px; margin:0; font-weight:900; letter-spacing:.2px;}
    .title .sub{font-size:12px; color:var(--muted); line-height:1.25;}

    .pill{
      display:inline-flex; gap:10px; align-items:center;
      padding:8px 10px;
      background: rgba(17,24,36,.75);
      border:1px solid rgba(34,48,68,.9);
      border-radius:999px;
      box-shadow: var(--shadow);
      font-size:12px;
      color:var(--muted);
      white-space:nowrap;
    }
    .pill b{color:var(--text); font-weight:900}

    .toast{
      max-width: 460px;
      overflow:hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    main{
      max-width:1480px; margin:0 auto; padding:14px;
      display:grid; grid-template-columns: 360px 1fr;
      gap:14px;
    }

    .card{
      background: linear-gradient(180deg, rgba(17,24,36,.92), rgba(15,22,32,.84));
      border:1px solid rgba(34,48,68,.9);
      border-radius:var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .card h2{
      margin:0;
      padding:10px 12px;
      font-size:13px;
      letter-spacing:.2px;
      border-bottom:1px solid rgba(34,48,68,.7);
      color:#dce8f7;
      display:flex; align-items:center; justify-content:space-between; gap:10px;
    }
    .card h2 small{color:var(--muted); font-weight:800; font-size:11px;}
    .card .content{padding:10px;}

    .grid{display:grid; gap:10px;}
    .grid.cols2{grid-template-columns:1fr 1fr;}
    .grid.cols3{grid-template-columns:1fr 1fr 1fr;}

    label{display:flex; flex-direction:column; gap:6px; font-size:11px; color:var(--muted);}

    input, select, button{font-family:inherit;}
    input, select{
      width:100%;
      padding:9px 10px;
      border-radius:10px;
      border:1px solid rgba(34,48,68,.9);
      background: rgba(11,15,20,.55);
      color: var(--text);
      outline:none;
    }
    input:focus, select:focus{
      border-color: rgba(100,181,255,.55);
      box-shadow: 0 0 0 3px rgba(100,181,255,.12);
    }

    .btn{
      border:none;
      border-radius:12px;
      padding:10px 12px;
      cursor:pointer;
      font-weight:900;
      letter-spacing:.2px;
      user-select:none;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      gap:8px;
      white-space:nowrap;
      background: rgba(159,176,195,.12);
      color:#e7eef7;
      border:1px solid rgba(159,176,195,.35);
      transition: transform .06s ease, filter .15s ease;
    }
    .btn:hover{filter: brightness(1.08);}
    .btn:active{transform: translateY(1px);}
    .btn.good{background: rgba(61,220,151,.16); color: #bdf8de; border:1px solid rgba(61,220,151,.45);}
    .btn.bad{background: rgba(255,91,110,.14); color: #ffd0d7; border:1px solid rgba(255,91,110,.45);}
    .btn.neutral{background: rgba(100,181,255,.14); color: #d4ebff; border:1px solid rgba(100,181,255,.45);}
    .btn.warn{background: rgba(255,207,91,.12); color: #ffe8b2; border:1px solid rgba(255,207,91,.35);}
    .btn.small{padding:8px 10px; border-radius:10px; font-size:12px;}

    .row{display:flex; gap:10px; align-items:center;}
    .row.wrap{flex-wrap:wrap;}
    .sep{height:1px; background: rgba(34,48,68,.7); margin: 12px 0;}
    .mono{font-family:var(--mono)}
    .muted{color:var(--muted)}
    .kbd{
      font-family: var(--mono);
      font-size: 11px;
      padding: 2px 6px;
      border-radius: 8px;
      border:1px solid rgba(34,48,68,.9);
      background: rgba(11,15,20,.55);
      color: rgba(231,238,247,.95);
    }

    .stat{
      display:flex; flex-direction:column; gap:2px;
      padding:9px 10px;
      border-radius:12px;
      border:1px solid rgba(34,48,68,.7);
      background: rgba(11,15,20,.35);
      min-width: 0;
    }
    .stat .k{font-size:11px; color:var(--muted);}
    .stat .v{font-family:var(--mono); font-size:13px; font-weight:900; color:var(--text); overflow:hidden; text-overflow:ellipsis; white-space:nowrap;}

    .chartTopBar{
      padding:10px 12px;
      border-bottom:1px solid rgba(34,48,68,.7);
      display:flex; align-items:center; justify-content:space-between;
      gap:10px; flex-wrap:wrap;
    }
    .chartTopBar .left{display:flex; gap:10px; align-items:center; flex-wrap:wrap;}
    .chartTopBar .right{display:flex; gap:10px; align-items:center; flex-wrap:wrap;}

    .miniField{
      display:flex; align-items:center; gap:8px;
      padding:8px 10px;
      border-radius:12px;
      border:1px solid rgba(34,48,68,.7);
      background: rgba(11,15,20,.35);
      color: var(--muted);
      font-size:12px;
      user-select:none;
      white-space:nowrap;
    }
    .miniField input{width:92px; padding:8px 8px; border-radius:10px; font-size:12px;}
    .miniField select{width:190px; padding:8px 8px; border-radius:10px; font-size:12px;}

    .toggle{
      display:flex; align-items:center; gap:8px;
      padding:8px 10px;
      border-radius:12px;
      border:1px solid rgba(34,48,68,.7);
      background: rgba(11,15,20,.35);
      color: var(--muted);
      font-size:12px;
      user-select:none;
      cursor:pointer;
      white-space:nowrap;
    }
    .toggle input{width:auto; transform: translateY(1px);}

    .speedGroup{
      display:flex; align-items:center; gap:6px;
      padding:6px;
      border-radius:12px;
      border:1px solid rgba(34,48,68,.7);
      background: rgba(11,15,20,.35);
    }
    .speedBtn{
      border:none; cursor:pointer;
      padding:7px 10px;
      border-radius:10px;
      font-weight:900; font-size:12px;
      background: rgba(159,176,195,.10);
      border:1px solid rgba(159,176,195,.25);
      color: rgba(231,238,247,.92);
    }
    .speedBtn.active{
      background: rgba(100,181,255,.16);
      border-color: rgba(100,181,255,.55);
      color: rgba(212,235,255,.98);
    }

    .chartWrap{
      height: 680px;
      padding: 10px 12px 12px;
      resize: vertical;
      overflow: hidden;
      min-height: 340px;
      max-height: calc(100vh - 220px);
    }
    canvas{
      width:100%;
      height:100%;
      display:block;
      border-radius:12px;
      border:1px solid rgba(34,48,68,.7);
      background: rgba(5,8,12,.65);
      touch-action: none;
      cursor: grab;
    }

    .overlayHelp{
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,.55);
      backdrop-filter: blur(6px);
      display:none;
      z-index: 10;
      align-items:center;
      justify-content:center;
      padding: 18px;
    }
    .overlayHelp.open{display:flex;}
    .helpCard{
      max-width: 860px;
      width: 100%;
      border-radius: 16px;
      border:1px solid rgba(34,48,68,.95);
      background: linear-gradient(180deg, rgba(17,24,36,.96), rgba(11,15,20,.92));
      box-shadow: var(--shadow);
      padding: 14px;
    }
    .helpGrid{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
      margin-top: 10px;
    }
    .helpItem{
      border:1px solid rgba(34,48,68,.7);
      border-radius: 12px;
      background: rgba(11,15,20,.35);
      padding: 10px;
      font-size: 12px;
      color: var(--muted);
      line-height: 1.35;
    }
    .helpItem b{ color: var(--text); }

    @media (max-width: 1220px){
      main{grid-template-columns: 1fr;}
      .chartWrap{height:420px;}
      .miniField input{width:110px;}
      .miniField select{width:210px;}
    }
  </style>
</head>

<body>
<header>
  <div class="row">
    <div class="title">
      <h1>Market Sandbox ‚Äî TV-like Chart üìà</h1>
      <div class="sub">
        <span class="kbd">Wheel</span> X zoom ‚Ä¢ <span class="kbd">Shift+Wheel</span> Y zoom ‚Ä¢
        <span class="kbd">Drag</span> X pan ‚Ä¢ <span class="kbd">Shift+Drag</span> Y pan ‚Ä¢
        <span class="kbd">Ctrl+Click</span> Limit ‚Ä¢ <span class="kbd">Alt+Click</span> Cancel ‚Ä¢
        <span class="kbd">?</span> Help
      </div>
    </div>

    <div class="row wrap">
      <div class="pill">Symbol: <b id="sym">NQ (sim)</b></div>
      <div class="pill">Vol preset: <b id="hdrVol">NY Killzone</b></div>
      <div class="pill">Price: <b id="hdrPrice">‚Äî</b></div>
      <div class="pill">Pos: <b id="hdrPos">0</b></div>
      <div class="pill">uPnL: <b id="hdrPnL">‚Äî</b></div>
      <div class="pill">Speed: <b id="hdrSpeed">1.0x</b></div>
      <div class="pill toast">Status: <b id="toast">Ready</b></div>
    </div>
  </div>
</header>

<main>
  <!-- LEFT PANEL -->
  <div class="card">
    <h2>Trading <small>market / limit / drip</small></h2>
    <div class="content grid">
      <div class="grid cols2">
        <label>Quantity (qty)<input id="qty" type="number" step="1" min="1" value="1" /></label>
        <label>Slippage (ticks)<input id="slip" type="number" step="1" min="0" value="1" /></label>
      </div>

      <div class="grid cols2">
        <button class="btn good" id="buyMkt">‚¨ÜÔ∏è Buy MKT</button>
        <button class="btn bad" id="sellMkt">‚¨áÔ∏è Sell MKT</button>
      </div>

      <div class="sep"></div>

      <div class="grid cols2">
        <label>Limit side
          <select id="limitSide">
            <option value="buy">Buy Limit</option>
            <option value="sell">Sell Limit</option>
          </select>
        </label>
        <label>Limit price<input id="limitPrice" type="number" step="0.25" value="0" /></label>
      </div>
      <button class="btn neutral" id="placeLimit">‚ûï Place Limit</button>

      <div class="sep"></div>

      <div class="grid cols3">
        <label>Ladder side
          <select id="ladderSide"><option value="buy">Buy ladder</option><option value="sell">Sell ladder</option></select>
        </label>
        <label>Levels<input id="ladderLevels" type="number" step="1" min="1" value="8" /></label>
        <label>Step (pts)<input id="ladderStep" type="number" step="0.25" min="0.25" value="5" /></label>
      </div>
      <div class="grid cols2">
        <label>Start price<input id="ladderStart" type="number" step="0.25" value="0" /></label>
        <label>Qty per level<input id="ladderQty" type="number" step="1" min="1" value="1" /></label>
      </div>
      <button class="btn warn" id="placeLadder">ü™ú Place Ladder</button>

      <div class="sep"></div>

      <div class="grid cols3">
        <label>Drip side
          <select id="dripSide">
            <option value="buy">Drip Buy</option>
            <option value="sell">Drip Sell</option>
          </select>
        </label>
        <label>Every (sec)<input id="dripEvery" type="number" min="0.2" step="0.1" value="2" /></label>
        <label>Qty each<input id="dripQty" type="number" min="1" step="1" value="1" /></label>
      </div>
      <div class="grid cols2">
        <button class="btn neutral" id="dripToggle">‚ñ∂ Start Drip</button>
        <button class="btn" id="dripStop">‚ñ† Stop</button>
      </div>

      <div class="sep"></div>

      <div class="grid cols2">
        <button class="btn" id="cancelAll">Cancel All</button>
        <button class="btn" id="flatten">Flatten (MKT)</button>
      </div>

      <div class="sep"></div>

      <h2 style="border:none; padding:0; margin-top:2px;">Market Engine <small>volatility + timing</small></h2>

      <div class="grid cols2">
        <label>Volatility preset
          <select id="volPreset">
            <option value="nyopen">NY Open Vol</option>
            <option value="nykz" selected>NY Killzone</option>
            <option value="london">London</option>
            <option value="premarket">Premarket</option>
            <option value="asia">Asia</option>
          </select>
        </label>
        <label>Volatility (1‚Äì16)<input id="volValue" type="number" min="1" max="16" step="0.1" value="9.2" /></label>
      </div>

      <div class="grid cols2">
        <label>Base ticks / sim-sec (20‚Äì200)<input id="simHzBase" type="number" step="1" min="20" max="200" value="75" /></label>
        <label>Impact (0‚Äì20)<input id="impact" type="number" step="1" min="0" max="20" value="10" /></label>
      </div>

      <div class="grid cols3">
        <label>Tick size<input id="tick" type="number" step="0.01" min="0.01" value="0.25" /></label>
        <label>Spread (ticks)<input id="spread" type="number" step="1" min="0" value="1" /></label>
        <label>Right space (bars)<input id="futureBars" type="number" step="5" min="0" max="300" value="40" /></label>
      </div>

      <div class="grid cols2">
        <label>Timeframe
          <select id="timeframe">
            <option value="1">1s</option>
            <option value="5" selected>5s</option>
            <option value="15">15s</option>
            <option value="60">1m</option>
            <option value="300">5m</option>
            <option value="900">15m</option>
          </select>
        </label>
        <label>Bars on screen<input id="visibleBars" type="number" step="5" min="20" max="700" value="160" /></label>
      </div>

      <div class="grid cols2">
        <button class="btn neutral" id="pause">‚è∏ Pause</button>
        <button class="btn neutral" id="reset">üîÅ Reset</button>
      </div>
    </div>
  </div>

  <!-- CENTER CHART -->
  <section class="card">
    <h2>Chart <small>sandbox</small></h2>

    <div class="chartTopBar">
      <div class="left">
        <button class="btn good" id="buyMktTop" title="Hotkey: B">‚¨ÜÔ∏è Buy</button>
        <button class="btn bad" id="sellMktTop" title="Hotkey: S">‚¨áÔ∏è Sell</button>

        <div class="toggle" id="followWrap" title="Hotkey: F">
          <input id="follow" type="checkbox" checked />
          <span>Auto-follow</span>
        </div>

        <div class="toggle" id="autoYWrap" title="Double-click chart too">
          <input id="autoY" type="checkbox" checked />
          <span>Auto Y</span>
        </div>

        <div class="speedGroup" title="Speed presets">
          <button class="speedBtn" data-speed="0.5">0.5x</button>
          <button class="speedBtn active" data-speed="1">1x</button>
          <button class="speedBtn" data-speed="2">2x</button>
          <button class="speedBtn" data-speed="5">5x</button>
          <button class="speedBtn" data-speed="10">10x</button>
        </div>

        <button class="btn small neutral" id="stepTick" title="Step 1 tick (paused)">‚è≠ Step</button>

        <div class="miniField">
          Tool
          <select id="tool" title="Hotkeys: 1-5">
            <option value="cursor" selected>Cursor</option>
            <option value="trend">Trendline</option>
            <option value="rect">Rectangle</option>
            <option value="hline">H-Line</option>
            <option value="erase">Eraser</option>
          </select>
        </div>

        <button class="btn small" id="undo" title="Ctrl+Z">‚Ü© Undo</button>
        <button class="btn small" id="clearDraw">üßº Clear</button>

        <div class="toggle" id="indVolWrap">
          <input id="indVol" type="checkbox" checked />
          <span>Volume</span>
        </div>
        <div class="toggle" id="indVwapWrap">
          <input id="indVwap" type="checkbox" checked />
          <span>VWAP</span>
        </div>
        <div class="toggle" id="indMaWrap">
          <input id="indMa" type="checkbox" checked />
          <span>20m SMA</span>
        </div>

        <button class="btn small neutral" id="openHelp" title="Hotkey: ?">‚ùî Help</button>
      </div>

      <div class="right">
        <div class="miniField mono">
          Ctrl+Click = Limit (LMB buy / RMB sell) ‚Ä¢ Alt+Click = Cancel nearest ‚Ä¢ Pinch = X zoom ‚Ä¢ Two-finger drag = Y pan
        </div>
      </div>
    </div>

    <div class="chartWrap">
      <canvas id="chart"></canvas>
    </div>

    <div class="content">
      <div class="row wrap">
        <div class="stat"><div class="k">Last</div><div class="v" id="stLast">‚Äî</div></div>
        <div class="stat"><div class="k">Bid / Ask</div><div class="v" id="stBA">‚Äî</div></div>
        <div class="stat"><div class="k">Net Pos</div><div class="v" id="stPos">0</div></div>
        <div class="stat"><div class="k">Avg</div><div class="v" id="stAvg">‚Äî</div></div>
        <div class="stat"><div class="k">uPnL</div><div class="v" id="stPnL">‚Äî</div></div>
        <div class="stat"><div class="k">Window</div><div class="v" id="stWin">‚Äî</div></div>
      </div>
    </div>
  </section>
</main>

<!-- Help overlay -->
<div class="overlayHelp" id="helpOverlay">
  <div class="helpCard">
    <div class="row" style="justify-content:space-between; align-items:center;">
      <div style="font-weight:900;">Hotkeys / Controls</div>
      <button class="btn small" id="closeHelp">‚úñ Close</button>
    </div>
    <div class="helpGrid">
      <div class="helpItem"><b>B</b> Buy Market ‚Ä¢ <b>S</b> Sell Market</div>
      <div class="helpItem"><b>Space</b> Pause/Resume ‚Ä¢ <b>Step</b> = 1 tick (paused)</div>
      <div class="helpItem"><b>F</b> Auto-follow on/off</div>
      <div class="helpItem"><b>C</b> Cancel All ‚Ä¢ <b>X</b> Flatten</div>
      <div class="helpItem"><b>Ctrl+Z</b> Undo drawing</div>
      <div class="helpItem"><b>1-5</b> Tools (Cursor/Trend/Rect/HLine/Eraser)</div>
      <div class="helpItem"><b>Ctrl+Click</b> Place Limit (LMB=BUY, RMB=SELL)</div>
      <div class="helpItem"><b>Alt+Click</b> Cancel nearest limit</div>
      <div class="helpItem"><b>Wheel</b> X zoom ‚Ä¢ <b>Shift+Wheel</b> Y zoom</div>
      <div class="helpItem"><b>Drag</b> X pan ‚Ä¢ <b>Shift+Drag</b> Y pan</div>
      <div class="helpItem"><b>Pinch</b> X zoom (mobile) ‚Ä¢ <b>Two-finger drag</b> Y pan (mobile)</div>
      <div class="helpItem"><b>+</b>/<b>-</b> qty +/-</div>
      <div class="helpItem"><b>?</b> open/close help</div>
    </div>
  </div>
</div>

<script>
(() => {
  const $ = (id) => document.getElementById(id);
  const clamp = (x, a, b) => Math.max(a, Math.min(b, x));
  const lerp  = (a,b,t) => a + (b-a)*t;
  const roundTo = (x, step) => Math.round(x / step) * step;

  function decimalsFor(step){
    if (!Number.isFinite(step) || step <= 0) return 2;
    // handle 0.25, 0.01, 0.0001, etc
    const s = String(step);
    if (s.includes("e-")) return parseInt(s.split("e-")[1], 10) || 2;
    const dot = s.indexOf(".");
    return dot >= 0 ? (s.length - dot - 1) : 0;
  }

  // Box-Muller normal
  function randn() {
    let u = 0, v = 0;
    while (u === 0) u = Math.random();
    while (v === 0) v = Math.random();
    return Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
  }

  const VOL_PRESETS = {
    nyopen:    { name:"NY Open Vol", vol: 11.5 },
    nykz:      { name:"NY Killzone", vol:  9.2 },
    london:    { name:"London",      vol:  6.2 },
    premarket: { name:"Premarket",   vol:  4.6 },
    asia:      { name:"Asia",        vol:  3.4 },
  };

  const canvas = $("chart");
  const ctx = canvas.getContext("2d", { alpha:true });

  const state = {
    symbol: "NQ (sim)",

    // market micro
    tickSize: 0.25,
    spreadTicks: 1,

    // smoothed params
    p: { vol: 9.2, impact: 10, simHzBase: 75, fillProb: 0.92 },
    target: { vol: 9.2, impact: 10, simHzBase: 75, fillProb: 0.92 },

    volPresetKey: "nykz",
    speedMul: 1,
    paused: false,

    // simulation core (more NQ-like)
    sim: {
      price: 17000,
      drift: 0,            // points/sec
      driftTarget: 0,
      sigma: 3.2,          // points/sqrt(sec)
      sigmaTarget: 3.2,
      volOfVol: 0.55,      // how fast sigma moves
      meanRev: 0.18,       // sigma mean reversion
      nextRegimeT: 30,
      jumpProb: 0.0012,
      jumpScale: 14,       // points
      flow: 0,
      flowDecay: 0.92,
      vel: 0
    },

    // time
    simTime: 0,
    tickCount: 0,
    ticks: [],
    maxTicks: 220000,

    // bars
    tfSec: 5,
    bars: [],
    curBar: null,

    // trading
    pos: 0,
    avg: null,
    nextOrderId: 1,
    limits: [],

    // drip
    drip: { on:false, timer:null, side:"buy" },

    // view (NEW ENGINE)
    view: {
      visibleBars: 160,
      futureBars: 40,
      follow: true,
      end: 0.0, // float "rightmost" virtual position (includes future space)
    },

    // y view
    y: { auto:true, scale:1.0, offset:0.0 },

    // pointers / gestures
    pointers: new Map(),
    dragStart: null,
    yDragStart: null,
    gestureStart: null,

    // crosshair
    cross: { on:false, x:0, y:0, pos:null, idx:null, price:null },

    // drawings
    tool: "cursor",
    drawings: [],
    pending: null,

    // indicators
    indicators: { vol:true, vwap:true, ma:true },
    indCache: { tfSec:null, len:0, maN:0, vwap:[], ma:[] },

    // ui
    toastUntil: 0
  };

  $("sym").textContent = state.symbol;

  function toast(msg) {
    $("toast").textContent = msg;
    state.toastUntil = performance.now() + 1800;
  }

  function resizeCanvasToDisplaySize() {
    const rect = canvas.getBoundingClientRect();
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    const displayW = Math.round(rect.width * dpr);
    const displayH = Math.round(rect.height * dpr);
    if (canvas.width !== displayW || canvas.height !== displayH) {
      canvas.width = displayW;
      canvas.height = displayH;
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0); // draw in CSS px
    }
  }
  window.addEventListener("resize", resizeCanvasToDisplaySize);

  function setVolPreset(key) {
    const p = VOL_PRESETS[key] || VOL_PRESETS.nykz;
    state.volPresetKey = key;
    $("hdrVol").textContent = p.name;
    $("volValue").value = String(p.vol);
    state.target.vol = p.vol;
    toast(`Vol preset: ${p.name}`);
  }

  // ===== Trading engine
  function getBidAsk() {
    const spread = state.spreadTicks * state.tickSize;
    const mid = state.sim.price;
    return { bid: mid - spread/2, ask: mid + spread/2 };
  }

  function computeUPnL() {
    if (!state.pos || state.avg == null) return null;
    return (state.sim.price - state.avg) * state.pos;
  }

  function applyFill(side, qty, fillPrice) {
    const oldPos = state.pos;
    const newPos = oldPos + (side === "buy" ? qty : -qty);

    if (oldPos === 0) state.avg = fillPrice;
    else if (Math.sign(oldPos) === Math.sign(newPos) && newPos !== 0) {
      const oldAbs = Math.abs(oldPos);
      const newAbs = Math.abs(newPos);
      const addQty = newAbs - oldAbs;
      if (addQty > 0) state.avg = (state.avg * oldAbs + fillPrice * addQty) / newAbs;
    } else if (newPos === 0) state.avg = null;
    else if (Math.sign(oldPos) !== Math.sign(newPos)) state.avg = fillPrice;

    state.pos = newPos;

    // order-flow pressure
    state.sim.flow += (side === "buy" ? qty : -qty);
  }

  function marketOrder(side, qty, slipTicks) {
    const { bid, ask } = getBidAsk();
    const slip = slipTicks * state.tickSize;
    const fill = side === "buy" ? (ask + slip) : (bid - slip);
    applyFill(side, qty, fill);
    toast(`${side.toUpperCase()} MKT filled`);
  }

  function placeLimit(side, price, qty) {
    price = roundTo(price, state.tickSize);
    const id = state.nextOrderId++;
    state.limits.push({ id, side, price, qty, left: qty, createdAt: state.simTime });
    toast(`Limit placed (#${id})`);
  }

  function cancelOrder(id) {
    const idx = state.limits.findIndex(o => o.id === id);
    if (idx >= 0) {
      state.limits.splice(idx, 1);
      toast(`Limit cancelled (#${id})`);
    }
  }

  function cancelAll() {
    const n = state.limits.length;
    state.limits = [];
    toast(`Cancelled ${n} orders`);
  }

  function flatten() {
    if (state.pos === 0) { toast("Position already flat"); return; }
    const qty = Math.abs(state.pos);
    const side = state.pos > 0 ? "sell" : "buy";
    marketOrder(side, qty, getSlip());
    toast("Flatten done");
  }

  function placeLadder(side, start, levels, step, qtyPerLevel) {
    start = roundTo(start, state.tickSize);
    step = roundTo(Math.max(state.tickSize, step), state.tickSize);
    for (let i = 0; i < levels; i++) {
      const p = side === "buy" ? start - i * step : start + i * step;
      placeLimit(side, p, qtyPerLevel);
    }
  }

  function cancelNearestLimitByPrice(price) {
    if (!state.limits.length) return false;
    let best = null;
    for (const o of state.limits) {
      const d = Math.abs(o.price - price);
      if (!best || d < best.d) best = { d, id: o.id };
    }
    const maxDelta = state.tickSize * 6;
    if (best && best.d <= maxDelta) { cancelOrder(best.id); return true; }
    return false;
  }

  function matchLimits() {
    const { bid, ask } = getBidAsk();
    const filledIds = [];

    for (const o of state.limits) {
      if (o.left <= 0) { filledIds.push(o.id); continue; }

      const crossed = (o.side === "buy") ? (ask <= o.price) : (bid >= o.price);
      if (!crossed) continue;

      // slightly smarter fill: closer cross => higher prob
      const dist = o.side === "buy" ? (o.price - ask) : (bid - o.price);
      const distTicks = dist / Math.max(1e-9, state.tickSize);
      const boost = clamp(distTicks / 4, 0, 1);
      const base = clamp(state.p.fillProb, 0.55, 0.99);
      const prob = clamp(base + 0.12*boost, 0.55, 0.995);
      if (Math.random() > prob) continue;

      const chunk = Math.max(1, Math.floor(Math.max(1, o.qty) * (0.35 + 0.55 * prob)));
      const fillQty = Math.min(o.left, chunk);

      o.left -= fillQty;
      applyFill(o.side, fillQty, o.price);

      if (o.left <= 0) filledIds.push(o.id);
    }

    if (filledIds.length) state.limits = state.limits.filter(o => !filledIds.includes(o.id));
  }

  // ===== Bars
  function barKeyForTime(t, tfSec) { return Math.floor(t / tfSec); }

  function ensureBarForTick(t, price, vol) {
    const key = barKeyForTime(t, state.tfSec);

    if (!state.curBar) {
      state.curBar = { key, idx: key, o: price, h: price, l: price, c: price, v: vol };
      return;
    }

    if (key === state.curBar.key) {
      state.curBar.h = Math.max(state.curBar.h, price);
      state.curBar.l = Math.min(state.curBar.l, price);
      state.curBar.c = price;
      state.curBar.v += vol;
      return;
    }

    state.bars.push(state.curBar);
    if (state.bars.length > 12000) state.bars.shift();

    state.curBar = { key, idx: key, o: price, h: price, l: price, c: price, v: vol };

    state.indCache.len = 0; // invalidate indicators
  }

  function rebuildBars(tfSec) {
    state.tfSec = tfSec;
    state.bars = [];
    state.curBar = null;
    state.indCache = { tfSec:null, len:0, maN:0, vwap:[], ma:[] };

    for (const tk of state.ticks) ensureBarForTick(tk.t, tk.p, tk.v);

    // keep view stable after TF switch: clamp end and optionally follow
    const all = getAllBarsForRender();
    const last = Math.max(0, all.length - 1);
    const maxEnd = last + state.view.futureBars;
    if (state.view.follow) state.view.end = maxEnd;
    else state.view.end = clamp(state.view.end, Math.max(0, state.view.visibleBars - 1), maxEnd);

    toast(`Timeframe: ${tfSec >= 60 ? (tfSec/60 + "m") : (tfSec + "s")}`);
  }

  function getAllBarsForRender() {
    const arr = state.bars.slice();
    if (state.curBar) arr.push(state.curBar);
    return arr;
  }

  // ===== View window (NEW)
  function getViewWindow() {
    const all = getAllBarsForRender();
    const n = all.length;
    const vis = clamp(state.view.visibleBars, 20, 700);

    const last = Math.max(0, n - 1);
    const maxEnd = last + state.view.futureBars;

    let end = state.view.follow ? maxEnd : state.view.end;
    end = clamp(end, Math.max(0, vis - 1), maxEnd);

    const start = end - vis + 1; // float
    return { all, n, last, vis, start, end, maxEnd };
  }

  // ===== Price ranges
  function computeAutoPriceRange(vwin) {
    let min = Infinity, max = -Infinity;

    const i0 = Math.floor(vwin.start);
    const i1 = Math.ceil(vwin.end);

    for (let i = i0; i <= i1; i++) {
      if (i < 0 || i >= vwin.n) continue;
      const b = vwin.all[i];
      min = Math.min(min, b.l);
      max = Math.max(max, b.h);
    }

    for (const o of state.limits) {
      min = Math.min(min, o.price);
      max = Math.max(max, o.price);
    }

    if (!Number.isFinite(min) || !Number.isFinite(max) || min === max) {
      min = state.sim.price - 50 * state.tickSize;
      max = state.sim.price + 50 * state.tickSize;
    }

    const pad = (max - min) * 0.12 + state.tickSize * 18;
    return { min: min - pad, max: max + pad };
  }

  function computeViewPriceRange(autoRange) {
    if (state.y.auto) return autoRange;

    const cAuto = (autoRange.min + autoRange.max) / 2;
    const c = cAuto + state.y.offset;
    const halfAuto = (autoRange.max - autoRange.min) / 2;
    const half = halfAuto * clamp(state.y.scale, 0.20, 12.0);

    return { min: c - half, max: c + half };
  }

  // ===== Geometry
  function buildGeo(vwin, pr) {
    const rect = canvas.getBoundingClientRect();
    const w = rect.width, h = rect.height;

    const leftPad = 74;
    const rightPad = 14;
    const topPad = 10;
    const bottomPad = 26;

    const volPanelH = state.indicators.vol ? Math.max(78, Math.floor((h - topPad - bottomPad) * 0.22)) : 0;
    const volGap = volPanelH ? 8 : 0;

    const plotX0 = leftPad;
    const plotX1 = w - rightPad;
    const priceY0 = topPad;
    const priceY1 = h - bottomPad - volPanelH - volGap;

    const volY0 = priceY1 + volGap;
    const volY1 = h - bottomPad;

    const plotW = Math.max(80, plotX1 - plotX0);
    const stepPx = plotW / Math.max(20, vwin.vis);
    const candleW = clamp(stepPx * 0.68, 3, 30);
    const gap = stepPx - candleW;

    const yOf = (p) => {
      const yy = priceY1 - ((p - pr.min) / (pr.max - pr.min)) * (priceY1 - priceY0);
      return clamp(yy, priceY0, priceY1);
    };

    const posOfX = (x) => vwin.start + (x - plotX0) / stepPx;
    const xOfPos = (pos) => plotX0 + (pos - vwin.start) * stepPx + gap/2;
    const xCenterOfPos = (pos) => xOfPos(pos) + candleW/2;

    const pricePerPx = (pr.max - pr.min) / Math.max(10, (priceY1 - priceY0));
    return { w,h,leftPad,rightPad,topPad,bottomPad,plotX0,plotX1,priceY0,priceY1,volY0,volY1,volPanelH,stepPx,candleW,gap,yOf,posOfX,xOfPos,xCenterOfPos,pricePerPx };
  }

  function canvasPointFromClient(e) {
    const r = canvas.getBoundingClientRect();
    return { x: (e.clientX - r.left), y: (e.clientY - r.top) };
  }

  function priceFromY(y, pr, geo) {
    const t = (geo.priceY1 - y) / (geo.priceY1 - geo.priceY0);
    const p = pr.min + t * (pr.max - pr.min);
    return roundTo(p, state.tickSize);
  }

  function niceStep(range, targetTicks=8) {
    const raw = range / targetTicks;
    const pow = Math.pow(10, Math.floor(Math.log10(raw)));
    const frac = raw / pow;
    let niceFrac;
    if (frac <= 1) niceFrac = 1;
    else if (frac <= 2) niceFrac = 2;
    else if (frac <= 5) niceFrac = 5;
    else niceFrac = 10;
    return niceFrac * pow;
  }

  function posForIdx(idx, all) {
    // binary search (bars sorted by idx)
    let lo = 0, hi = all.length - 1;
    while (lo <= hi) {
      const mid = (lo + hi) >> 1;
      const v = all[mid].idx;
      if (v === idx) return mid;
      if (v < idx) lo = mid + 1;
      else hi = mid - 1;
    }
    return clamp(lo, 0, Math.max(0, all.length - 1));
  }

  // ===== Indicators
  function computeIndicators(allBars) {
    const tfSec = state.tfSec;
    const len = allBars.length;

    const wantMa = state.indicators.ma;
    const wantVwap = state.indicators.vwap;

    const maN = Math.max(1, Math.round((20 * 60) / tfSec)); // 20 min

    if (state.indCache.tfSec === tfSec &&
        state.indCache.len === len &&
        state.indCache.maN === maN &&
        state.indCache.vwap.length === len &&
        state.indCache.ma.length === len) {
      return state.indCache;
    }

    const vwap = new Array(len).fill(null);
    const ma = new Array(len).fill(null);

    if (wantVwap) {
      let cumPV = 0, cumV = 0;
      for (let i=0;i<len;i++) {
        const b = allBars[i];
        const v = Math.max(1, b.v || 1);
        const tp = (b.h + b.l + b.c) / 3;
        cumPV += tp * v;
        cumV += v;
        vwap[i] = cumPV / Math.max(1, cumV);
      }
    }

    if (wantMa) {
      let sum = 0;
      for (let i=0;i<len;i++) {
        sum += allBars[i].c;
        if (i >= maN) sum -= allBars[i - maN].c;
        if (i >= maN - 1) ma[i] = sum / maN;
      }
    }

    state.indCache = { tfSec, len, maN, vwap, ma };
    return state.indCache;
  }

  // ===== Drawings hit-test
  function distPointToSegment(px,py, x1,y1, x2,y2) {
    const dx = x2 - x1, dy = y2 - y1;
    if (dx === 0 && dy === 0) return Math.hypot(px-x1, py-y1);
    const t = ((px-x1)*dx + (py-y1)*dy) / (dx*dx + dy*dy);
    const tt = clamp(t, 0, 1);
    const cx = x1 + tt*dx, cy = y1 + tt*dy;
    return Math.hypot(px-cx, py-cy);
  }

  function hitTestDrawing(pt, vwin, pr, geo) {
    const px = pt.x, py = pt.y;
    const all = vwin.all;

    for (let k = state.drawings.length - 1; k >= 0; k--) {
      const d = state.drawings[k];

      if (d.type === "hline") {
        const y = geo.yOf(d.p);
        if (Math.abs(py - y) <= 6 && px >= geo.plotX0 && px <= geo.plotX1) return k;
      }

      if (d.type === "trend") {
        const p1 = posForIdx(d.x1, all);
        const p2 = posForIdx(d.x2, all);
        const x1 = geo.xCenterOfPos(p1), y1 = geo.yOf(d.y1);
        const x2 = geo.xCenterOfPos(p2), y2 = geo.yOf(d.y2);
        if (distPointToSegment(px,py,x1,y1,x2,y2) <= 7) return k;
      }

      if (d.type === "rect") {
        const p1 = posForIdx(d.x1, all);
        const p2 = posForIdx(d.x2, all);
        const x1 = geo.xOfPos(p1), x2 = geo.xOfPos(p2);
        const y1 = geo.yOf(d.y1), y2 = geo.yOf(d.y2);
        const l = Math.min(x1,x2), r = Math.max(x1,x2);
        const t = Math.min(y1,y2), b = Math.max(y1,y2);
        const onEdge = (
          (Math.abs(px-l)<=6 && py>=t && py<=b) ||
          (Math.abs(px-r)<=6 && py>=t && py<=b) ||
          (Math.abs(py-t)<=6 && px>=l && px<=r) ||
          (Math.abs(py-b)<=6 && px>=l && px<=r)
        );
        if (onEdge) return k;
      }
    }
    return -1;
  }

  // ===== Render
  function drawChart() {
    resizeCanvasToDisplaySize();
    const rect = canvas.getBoundingClientRect();
    const w = rect.width, h = rect.height;

    ctx.clearRect(0,0,w,h);

    const vwin = getViewWindow();
    if (vwin.n < 2) return;

    const autoRange = computeAutoPriceRange(vwin);
    const pr = computeViewPriceRange(autoRange);
    const geo = buildGeo(vwin, pr);

    const dec = decimalsFor(state.tickSize);

    // plot background
    ctx.fillStyle = "rgba(5,8,12,0.35)";
    ctx.fillRect(geo.plotX0, geo.priceY0, geo.plotX1-geo.plotX0, geo.priceY1-geo.priceY0);

    // left scale background
    ctx.fillStyle = "rgba(11,15,20,0.55)";
    ctx.fillRect(0, 0, geo.leftPad, h);

    // border line
    ctx.strokeStyle = "rgba(34,48,68,0.9)";
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(geo.leftPad + 0.5, 0);
    ctx.lineTo(geo.leftPad + 0.5, h);
    ctx.stroke();

    // grid + labels
    let step = niceStep(pr.max - pr.min, 8);
    step = Math.max(state.tickSize, roundTo(step, state.tickSize));
    const startP = Math.floor(pr.min / step) * step;

    ctx.font = "12px " + getComputedStyle(document.body).fontFamily;
    ctx.textBaseline = "middle";

    for (let p = startP; p <= pr.max + step; p += step) {
      const price = roundTo(p, state.tickSize);
      const y = geo.yOf(price);

      ctx.strokeStyle = "rgba(34,48,68,0.45)";
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(geo.plotX0, y);
      ctx.lineTo(geo.plotX1, y);
      ctx.stroke();

      ctx.fillStyle = "rgba(159,176,195,0.95)";
      ctx.fillText(price.toFixed(dec), 8, y);
    }

    // vertical guides
    ctx.strokeStyle = "rgba(34,48,68,0.35)";
    const every = Math.max(8, Math.round(vwin.vis/10));
    for (let i=0; i<=vwin.vis; i+=every) {
      const pos = vwin.start + i;
      const x = geo.xCenterOfPos(pos);
      ctx.beginPath(); ctx.moveTo(x, geo.priceY0); ctx.lineTo(x, geo.priceY1); ctx.stroke();
    }

    // bid/ask band
    const { bid, ask } = getBidAsk();
    const yBid = geo.yOf(bid), yAsk = geo.yOf(ask);
    ctx.fillStyle = "rgba(159,176,195,0.08)";
    ctx.fillRect(geo.plotX0, Math.min(yBid,yAsk), geo.plotX1-geo.plotX0, Math.abs(yBid-yAsk));

    // candles (only existing bars)
    const i0 = Math.floor(vwin.start);
    const i1 = Math.ceil(vwin.end);

    for (let i = i0; i <= i1; i++) {
      if (i < 0 || i >= vwin.n) continue;
      const b = vwin.all[i];

      const x = geo.xOfPos(i);
      const yO = geo.yOf(b.o), yH = geo.yOf(b.h), yL = geo.yOf(b.l), yC = geo.yOf(b.c);
      const up = b.c >= b.o;

      ctx.strokeStyle = up ? "rgba(61,220,151,0.85)" : "rgba(255,91,110,0.85)";
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.moveTo(x + geo.candleW/2, yH);
      ctx.lineTo(x + geo.candleW/2, yL);
      ctx.stroke();

      const bodyTop = Math.min(yO, yC);
      const bodyH = Math.max(2, Math.abs(yC - yO));
      ctx.fillStyle = up ? "rgba(61,220,151,0.30)" : "rgba(255,91,110,0.28)";
      ctx.strokeStyle = up ? "rgba(61,220,151,0.95)" : "rgba(255,91,110,0.95)";
      ctx.fillRect(x, bodyTop, geo.candleW, bodyH);
      ctx.strokeRect(x, bodyTop, geo.candleW, bodyH);
    }

    // indicators
    const allBars = getAllBarsForRender();
    const ind = computeIndicators(allBars);

    function drawLine(series, color) {
      ctx.strokeStyle = color;
      ctx.lineWidth = 2;
      ctx.beginPath();
      let started = false;
      for (let i = i0; i <= i1; i++) {
        if (i < 0 || i >= vwin.n) continue;
        const val = series[i];
        if (val == null) continue;
        const x = geo.xCenterOfPos(i);
        const y = geo.yOf(val);
        if (!started) { ctx.moveTo(x,y); started = true; }
        else ctx.lineTo(x,y);
      }
      if (started) ctx.stroke();
    }

    if (state.indicators.vwap) drawLine(ind.vwap, "rgba(255,207,91,0.85)");
    if (state.indicators.ma)   drawLine(ind.ma,   "rgba(100,181,255,0.85)");

    // volume panel
    if (state.indicators.vol && geo.volPanelH > 0) {
      ctx.fillStyle = "rgba(5,8,12,0.35)";
      ctx.fillRect(geo.plotX0, geo.volY0, geo.plotX1-geo.plotX0, geo.volY1-geo.volY0);

      let maxV = 1;
      for (let i = i0; i <= i1; i++) {
        if (i < 0 || i >= vwin.n) continue;
        maxV = Math.max(maxV, vwin.all[i].v || 1);
      }

      for (let i = i0; i <= i1; i++) {
        if (i < 0 || i >= vwin.n) continue;
        const b = vwin.all[i];
        const up = b.c >= b.o;
        const x = geo.xOfPos(i);
        const vh = ((b.v || 1) / maxV) * (geo.volY1 - geo.volY0 - 6);
        const y = geo.volY1 - vh;
        ctx.fillStyle = up ? "rgba(61,220,151,0.22)" : "rgba(255,91,110,0.20)";
        ctx.fillRect(x, y, geo.candleW, vh);
      }

      ctx.strokeStyle = "rgba(34,48,68,0.6)";
      ctx.beginPath();
      ctx.moveTo(geo.plotX0, geo.volY0 + 0.5);
      ctx.lineTo(geo.plotX1, geo.volY0 + 0.5);
      ctx.stroke();
    }

    // limits
    for (const o of state.limits) {
      const y = geo.yOf(o.price);
      ctx.strokeStyle = o.side === "buy" ? "rgba(61,220,151,0.65)" : "rgba(255,91,110,0.65)";
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.moveTo(geo.plotX0, y);
      ctx.lineTo(geo.plotX1, y);
      ctx.stroke();

      ctx.fillStyle = o.side === "buy" ? "rgba(61,220,151,0.9)" : "rgba(255,91,110,0.9)";
      ctx.fillText(`${o.side.toUpperCase()} ${o.price.toFixed(dec)} (${o.left})`, geo.plotX0 + 10, y - 10);
    }

    // drawings
    for (const d of state.drawings) {
      if (d.type === "hline") {
        const y = geo.yOf(d.p);
        ctx.strokeStyle = "rgba(255,207,91,0.70)";
        ctx.lineWidth = 1.6;
        ctx.beginPath(); ctx.moveTo(geo.plotX0, y); ctx.lineTo(geo.plotX1, y); ctx.stroke();
      }
      if (d.type === "trend") {
        const p1 = posForIdx(d.x1, vwin.all);
        const p2 = posForIdx(d.x2, vwin.all);
        const x1 = geo.xCenterOfPos(p1), y1 = geo.yOf(d.y1);
        const x2 = geo.xCenterOfPos(p2), y2 = geo.yOf(d.y2);
        ctx.strokeStyle = "rgba(100,181,255,0.85)";
        ctx.lineWidth = 2.0;
        ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();
      }
      if (d.type === "rect") {
        const p1 = posForIdx(d.x1, vwin.all);
        const p2 = posForIdx(d.x2, vwin.all);
        const x1 = geo.xOfPos(p1), x2 = geo.xOfPos(p2);
        const y1 = geo.yOf(d.y1), y2 = geo.yOf(d.y2);
        const l = Math.min(x1,x2), r = Math.max(x1,x2);
        const t = Math.min(y1,y2), b = Math.max(y1,y2);
        ctx.fillStyle = "rgba(100,181,255,0.10)";
        ctx.strokeStyle = "rgba(100,181,255,0.70)";
        ctx.lineWidth = 1.8;
        ctx.fillRect(l,t,r-l,b-t);
        ctx.strokeRect(l,t,r-l,b-t);
      }
    }

    // pending preview
    if (state.pending && state.cross.idx != null && state.cross.price != null) {
      const p = state.pending;
      ctx.save();
      ctx.globalAlpha = 0.9;

      if (p.type === "trend") {
        const p1 = posForIdx(p.x1, vwin.all);
        const p2 = posForIdx(state.cross.idx, vwin.all);
        const x1 = geo.xCenterOfPos(p1), y1 = geo.yOf(p.y1);
        const x2 = geo.xCenterOfPos(p2), y2 = geo.yOf(state.cross.price);
        ctx.strokeStyle = "rgba(100,181,255,0.65)";
        ctx.lineWidth = 2;
        ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();
      }

      if (p.type === "rect") {
        const p1 = posForIdx(p.x1, vwin.all);
        const p2 = posForIdx(state.cross.idx, vwin.all);
        const x1 = geo.xOfPos(p1), y1 = geo.yOf(p.y1);
        const x2 = geo.xOfPos(p2), y2 = geo.yOf(state.cross.price);
        const l = Math.min(x1,x2), r = Math.max(x1,x2);
        const t = Math.min(y1,y2), b = Math.max(y1,y2);
        ctx.fillStyle = "rgba(100,181,255,0.08)";
        ctx.strokeStyle = "rgba(100,181,255,0.55)";
        ctx.lineWidth = 1.5;
        ctx.fillRect(l,t,r-l,b-t);
        ctx.strokeRect(l,t,r-l,b-t);
      }

      ctx.restore();
    }

    // last price label
    const yLast = geo.yOf(state.sim.price);
    ctx.fillStyle = "rgba(100,181,255,0.20)";
    ctx.fillRect(0, yLast - 12, geo.leftPad, 24);
    ctx.strokeStyle = "rgba(100,181,255,0.70)";
    ctx.lineWidth = 1.2;
    ctx.strokeRect(0.5, yLast - 11.5, geo.leftPad-1, 23);
    ctx.fillStyle = "rgba(211,236,255,0.98)";
    ctx.fillText(state.sim.price.toFixed(dec), 8, yLast);

    // crosshair
    if (state.cross.on && state.cross.price != null) {
      const x = clamp(state.cross.x, geo.plotX0, geo.plotX1);
      const y = clamp(state.cross.y, geo.priceY0, geo.priceY1);

      ctx.strokeStyle = "rgba(159,176,195,0.55)";
      ctx.lineWidth = 1;
      ctx.setLineDash([4,4]);
      ctx.beginPath(); ctx.moveTo(geo.plotX0, y); ctx.lineTo(geo.plotX1, y); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(x, geo.priceY0); ctx.lineTo(x, geo.priceY1); ctx.stroke();
      ctx.setLineDash([]);

      // price label
      ctx.fillStyle = "rgba(159,176,195,0.14)";
      ctx.fillRect(0, y - 12, geo.leftPad, 24);
      ctx.strokeStyle = "rgba(159,176,195,0.55)";
      ctx.strokeRect(0.5, y - 11.5, geo.leftPad-1, 23);
      ctx.fillStyle = "rgba(231,238,247,0.98)";
      ctx.fillText(state.cross.price.toFixed(dec), 8, y);
    }

    $("stWin").textContent =
      `${state.view.follow ? "FOLLOW" : "FREE"} | start ${vwin.start.toFixed(2)} ‚Üí end ${vwin.end.toFixed(2)} | vis ${vwin.vis}`;
  }

  function renderStats() {
    const { bid, ask } = getBidAsk();
    const upnl = computeUPnL();
    const dec = decimalsFor(state.tickSize);

    $("hdrPrice").textContent = state.sim.price.toFixed(dec);
    $("hdrPos").textContent = String(state.pos);
    $("hdrPnL").textContent = upnl == null ? "‚Äî" : upnl.toFixed(2);
    $("hdrSpeed").textContent = state.speedMul.toFixed(1) + "x";
    $("hdrVol").textContent = (VOL_PRESETS[state.volPresetKey] || VOL_PRESETS.nykz).name;

    $("stLast").textContent = state.sim.price.toFixed(dec);
    $("stBA").textContent = `${bid.toFixed(dec)} / ${ask.toFixed(dec)}`;
    $("stPos").textContent = String(state.pos);
    $("stAvg").textContent = state.avg == null ? "‚Äî" : state.avg.toFixed(dec);
    $("stPnL").textContent = upnl == null ? "‚Äî" : upnl.toFixed(2);

    if (performance.now() > state.toastUntil) $("toast").textContent = "Ready";
  }

  function getQty() {
    const q = Number($("qty").value || 1);
    return Math.max(1, Math.floor(q));
  }
  function setQty(v) {
    $("qty").value = String(Math.max(1, Math.floor(v)));
  }
  function getSlip() {
    const s = Number($("slip").value || 0);
    return Math.max(0, Math.floor(s));
  }

  function applySettingsFromUI() {
    state.tickSize = Number($("tick").value) || 0.25;
    state.spreadTicks = Math.max(0, Number($("spread").value || 1));

    state.view.visibleBars = clamp(Number($("visibleBars").value || 160), 20, 700);
    state.view.futureBars  = clamp(Number($("futureBars").value || 40), 0, 300);

    state.view.follow = $("follow").checked;
    state.y.auto = $("autoY").checked;

    state.target.simHzBase = clamp(Number($("simHzBase").value || 75), 20, 200);
    state.target.impact    = clamp(Number($("impact").value || 10), 0, 20);

    const volManual = clamp(Number($("volValue").value || state.target.vol), 1, 16);
    state.target.vol = volManual;

    state.indicators.vol  = $("indVol").checked;
    state.indicators.vwap = $("indVwap").checked;
    state.indicators.ma   = $("indMa").checked;

    state.tool = $("tool").value;
  }

  function smoothParams() {
    const t = 0.03;
    state.p.vol = lerp(state.p.vol, state.target.vol, t);
    state.p.impact = lerp(state.p.impact, state.target.impact, t);
    state.p.simHzBase = lerp(state.p.simHzBase, state.target.simHzBase, t);
  }

  // ===== Simulation (more NQ-like)
  function stepSimulationOnce() {
    smoothParams();

    const volKnob = clamp(state.p.vol, 1, 16);
    const impact = clamp(state.p.impact, 0, 20);

    // flow decay
    state.sim.flow *= state.sim.flowDecay;

    // dt (sim time)
    const dt = 1 / Math.max(20, state.p.simHzBase);
    state.simTime += dt;

    // regime change
    if (state.simTime >= state.sim.nextRegimeT) {
      // drift target in points/sec (small but meaningful)
      state.sim.driftTarget = randn() * (0.18 + 0.06 * (volKnob/10));
      // sigma target in points/sqrt(sec)
      const baseSig = 1.4 + 0.55 * volKnob; // knob to sigma
      state.sim.sigmaTarget = baseSig * (0.85 + 0.45 * Math.abs(randn()));
      state.sim.nextRegimeT = state.simTime + 18 + Math.random() * 70;
    }

    // drift smooth
    state.sim.drift = lerp(state.sim.drift, state.sim.driftTarget, 0.02);

    // sigma OU mean reversion
    const k = state.sim.meanRev;
    const vv = state.sim.volOfVol;
    const sig = state.sim.sigma;
    const dSig = k * (state.sim.sigmaTarget - sig) * dt + vv * Math.sqrt(dt) * randn();
    state.sim.sigma = clamp(sig + dSig, 0.6, 40);

    // core move: drift*dt + sigma*sqrt(dt)*N
    const dW = Math.sqrt(dt) * randn();
    let dp = state.sim.drift * dt + state.sim.sigma * dW;

    // flow impact (slower & more "pushy")
    dp += (state.sim.flow) * (impact * state.tickSize * 0.020);

    // microstructure smoothing
    state.sim.vel = state.sim.vel * 0.72 + dp * 0.85;

    // rare jumps (news-like)
    const jp = state.sim.jumpProb * (0.55 + 0.06 * volKnob);
    if (Math.random() < jp) {
      const dir = Math.sign(randn()) || 1;
      state.sim.vel += dir * (state.sim.jumpScale * (0.6 + Math.random() * 1.1)) * (0.65 + 0.05 * volKnob);
    }

    // clamp runaway
    const maxVel = (0.9 + 0.12 * volKnob) * (6.5 * state.tickSize);
    state.sim.vel = clamp(state.sim.vel, -maxVel, maxVel);

    // apply
    state.sim.price = roundTo(state.sim.price + state.sim.vel, state.tickSize);

    // synthetic tick volume
    const tickVol =
      1 +
      Math.floor(Math.abs(state.sim.vel) / Math.max(1e-6, state.tickSize * 0.20)) +
      Math.floor(Math.random() * 2) +
      Math.floor(Math.abs(state.sim.flow) * 0.2);

    state.tickCount++;
    state.ticks.push({ t: state.simTime, p: state.sim.price, v: tickVol });

    if (state.ticks.length > state.maxTicks) {
      state.ticks.splice(0, 35000);
      rebuildBars(state.tfSec);
      toast("History trimmed");
    }

    ensureBarForTick(state.simTime, state.sim.price, tickVol);
    matchLimits();

    // if follow: keep end pinned
    if (state.view.follow) {
      const all = getAllBarsForRender();
      const last = Math.max(0, all.length - 1);
      state.view.end = last + state.view.futureBars;
    }
  }

  // ===== Interaction helpers
  function disableFollowKeepEnd() {
    if (!state.view.follow) return;
    const v = getViewWindow();
    state.view.follow = false;
    $("follow").checked = false;
    state.view.end = v.end; // freeze current end
  }

  // ===== Wheel: X zoom / Y zoom anchored
  canvas.addEventListener("wheel", (e) => {
    e.preventDefault();
    applySettingsFromUI();

    const vwin = getViewWindow();
    if (vwin.n < 3) return;

    const autoRange = computeAutoPriceRange(vwin);
    const viewRange = computeViewPriceRange(autoRange);
    const geo = buildGeo(vwin, viewRange);

    const pt = canvasPointFromClient(e);
    const xFrac = clamp((pt.x - geo.plotX0) / Math.max(10, geo.plotX1-geo.plotX0), 0, 1);

    const dir = (e.deltaY > 0) ? +1 : -1;

    // Shift+Wheel => Y zoom
    if (e.shiftKey) {
      const anchorPrice = priceFromY(pt.y, viewRange, geo);
      const factor = (dir < 0) ? 0.88 : 1.14;

      if (state.y.auto) { state.y.auto = false; $("autoY").checked = false; }

      const oldScale = state.y.scale;
      const newScale = clamp(oldScale * factor, 0.20, 12.0);

      const cAuto = (autoRange.min + autoRange.max) / 2;
      const c0 = cAuto + state.y.offset;
      const half0 = ((autoRange.max - autoRange.min) / 2) * oldScale;

      const t = (anchorPrice - (c0 - half0)) / (2*half0);
      const half1 = ((autoRange.max - autoRange.min) / 2) * newScale;

      const min1 = anchorPrice - t * (2*half1);
      const c1 = min1 + half1;

      state.y.scale = newScale;
      state.y.offset = c1 - cAuto;
      return;
    }

    // X zoom
    const factor = (dir < 0) ? 0.85 : 1.18;
    const oldVis = state.view.visibleBars;
    const newVis = clamp(Math.round(oldVis * factor), 20, 700);
    if (newVis === oldVis) return;

    disableFollowKeepEnd();

    const anchorPos = vwin.start + xFrac * (vwin.vis - 1);
    state.view.visibleBars = newVis;
    $("visibleBars").value = String(newVis);

    const endTarget = anchorPos + (1 - xFrac) * (newVis - 1);
    const all = getAllBarsForRender();
    const last = Math.max(0, all.length - 1);
    const maxEnd = last + state.view.futureBars;

    state.view.end = clamp(endTarget, Math.max(0, newVis - 1), maxEnd);
    state.cross.on = true;
  }, { passive:false });

  canvas.addEventListener("contextmenu", (e) => e.preventDefault());

  // ===== Pointer events (smooth pan + pinch)
  let tapCandidate = null;

  canvas.addEventListener("pointerdown", (e) => {
    canvas.setPointerCapture(e.pointerId);
    state.pointers.set(e.pointerId, { x: e.clientX, y: e.clientY });

    applySettingsFromUI();

    tapCandidate = {
      id: e.pointerId,
      x: e.clientX, y: e.clientY,
      t: performance.now(),
      ctrl: e.ctrlKey,
      alt: e.altKey,
      shift: e.shiftKey,
      button: e.button
    };

    if (state.pointers.size === 1) {
      disableFollowKeepEnd();
      canvas.style.cursor = "grabbing";

      const vwin = getViewWindow();
      const autoRange = computeAutoPriceRange(vwin);
      const pr = computeViewPriceRange(autoRange);
      const geo = buildGeo(vwin, pr);

      state.cross.on = true;

      if (e.shiftKey) {
        if (state.y.auto) { state.y.auto = false; $("autoY").checked = false; }
        state.yDragStart = { y: e.clientY, offset: state.y.offset, pricePerPx: geo.pricePerPx };
        state.dragStart = null;
      } else {
        state.dragStart = { x: e.clientX, end: state.view.follow ? vwin.end : state.view.end, stepPx: geo.stepPx };
        state.yDragStart = null;
      }

      state.gestureStart = null;
    }

    if (state.pointers.size === 2) {
      disableFollowKeepEnd();

      const pts = [...state.pointers.values()];
      const dist = Math.hypot(pts[0].x - pts[1].x, pts[0].y - pts[1].y);
      const midX = (pts[0].x + pts[1].x) / 2;
      const midY = (pts[0].y + pts[1].y) / 2;

      const vwin = getViewWindow();
      const autoRange = computeAutoPriceRange(vwin);
      const pr = computeViewPriceRange(autoRange);
      const geo = buildGeo(vwin, pr);

      const ptCss = canvasPointFromClient({ clientX: midX, clientY: midY });
      const xFrac = clamp((ptCss.x - geo.plotX0) / Math.max(10, geo.plotX1-geo.plotX0), 0, 1);
      const anchorPos = vwin.start + xFrac * (vwin.vis - 1);

      state.gestureStart = {
        dist,
        midX, midY,
        vis: state.view.visibleBars,
        end: state.view.end,
        anchorPos,
        xFrac,
        yOffset: state.y.offset,
        pricePerPx: geo.pricePerPx
      };

      state.dragStart = null;
      state.yDragStart = null;
      state.cross.on = false;
    }
  });

  canvas.addEventListener("pointermove", (e) => {
    if (!state.pointers.has(e.pointerId)) return;
    state.pointers.set(e.pointerId, { x: e.clientX, y: e.clientY });

    applySettingsFromUI();

    // pinch + two-finger Y pan
    if (state.pointers.size === 2 && state.gestureStart) {
      const pts = [...state.pointers.values()];
      const dist = Math.hypot(pts[0].x - pts[1].x, pts[0].y - pts[1].y);
      const midX = (pts[0].x + pts[1].x) / 2;
      const midY = (pts[0].y + pts[1].y) / 2;

      const ratio = dist / Math.max(1, state.gestureStart.dist);
      const newVis = clamp(Math.round(state.gestureStart.vis / ratio), 20, 700);
      state.view.visibleBars = newVis;
      $("visibleBars").value = String(newVis);

      // keep zoom anchored around midpoint
      const endTarget = state.gestureStart.anchorPos + (1 - state.gestureStart.xFrac) * (newVis - 1);

      const all = getAllBarsForRender();
      const last = Math.max(0, all.length - 1);
      const maxEnd = last + state.view.futureBars;
      state.view.end = clamp(endTarget, Math.max(0, newVis - 1), maxEnd);

      // two-finger drag => Y pan
      const dy = midY - state.gestureStart.midY;
      if (Math.abs(dy) > 1.5) {
        if (state.y.auto) { state.y.auto = false; $("autoY").checked = false; }
        state.y.offset = state.gestureStart.yOffset + (-dy) * state.gestureStart.pricePerPx;
      }

      return;
    }

    // Y pan (shift drag)
    if (state.pointers.size === 1 && state.yDragStart) {
      const dy = e.clientY - state.yDragStart.y;
      state.y.offset = state.yDragStart.offset + (-dy) * state.yDragStart.pricePerPx;
    }

    // X pan (smooth)
    if (state.pointers.size === 1 && state.dragStart) {
      const dx = e.clientX - state.dragStart.x;
      const barsDelta = dx / Math.max(2, state.dragStart.stepPx);
      const endTarget = state.dragStart.end - barsDelta;

      const vwin = getViewWindow();
      const all = vwin.all;
      const last = Math.max(0, all.length - 1);
      const maxEnd = last + state.view.futureBars;

      state.view.end = clamp(endTarget, Math.max(0, state.view.visibleBars - 1), maxEnd);
    }

    // crosshair update (cursor tool only)
    const pt = canvasPointFromClient(e);
    const vwin = getViewWindow();
    if (vwin.n >= 2) {
      const autoRange = computeAutoPriceRange(vwin);
      const pr = computeViewPriceRange(autoRange);
      const geo = buildGeo(vwin, pr);

      const posF = geo.posOfX(pt.x);
      const pos = Math.round(posF);
      if (pos >= 0 && pos < vwin.n) {
        const idx = vwin.all[pos].idx;
        const price = priceFromY(pt.y, pr, geo);
        state.cross.x = pt.x;
        state.cross.y = pt.y;
        state.cross.pos = pos;
        state.cross.idx = idx;
        state.cross.price = price;
        state.cross.on = (state.tool === "cursor" || state.tool !== "cursor");
      }
    }
  });

  function handleTap(clientX, clientY, mods) {
    const vwin = getViewWindow();
    if (vwin.n < 2) return;

    const autoRange = computeAutoPriceRange(vwin);
    const pr = computeViewPriceRange(autoRange);
    const geo = buildGeo(vwin, pr);

    const pt = canvasPointFromClient({ clientX, clientY });
    if (pt.x < geo.plotX0 || pt.x > geo.plotX1 || pt.y < geo.priceY0 || pt.y > geo.priceY1) return;

    const pos = Math.round(geo.posOfX(pt.x));
    if (pos < 0 || pos >= vwin.n) return;

    const idx = vwin.all[pos].idx;
    const price = priceFromY(pt.y, pr, geo);

    if (mods && mods.alt) {
      const ok = cancelNearestLimitByPrice(price);
      if (!ok) toast("No nearby limit to cancel");
      return;
    }
    if (mods && mods.ctrl) {
      const side = (mods.button === 2) ? "sell" : "buy";
      placeLimit(side, price, getQty());
      return;
    }

    // drawings
    if (state.tool === "erase") {
      const k = hitTestDrawing(pt, vwin, pr, geo);
      if (k >= 0) state.drawings.splice(k, 1);
      state.pending = null;
      return;
    }
    if (state.tool === "hline") {
      state.drawings.push({ type:"hline", p: price });
      state.pending = null;
      return;
    }
    if (state.tool === "trend") {
      if (!state.pending) state.pending = { type:"trend", x1: idx, y1: price };
      else { state.drawings.push({ type:"trend", x1: state.pending.x1, y1: state.pending.y1, x2: idx, y2: price }); state.pending = null; }
      return;
    }
    if (state.tool === "rect") {
      if (!state.pending) state.pending = { type:"rect", x1: idx, y1: price };
      else { state.drawings.push({ type:"rect", x1: state.pending.x1, y1: state.pending.y1, x2: idx, y2: price }); state.pending = null; }
      return;
    }
  }

  function pointerUpCommon(e) {
    if (state.pointers.has(e.pointerId)) state.pointers.delete(e.pointerId);

    if (tapCandidate && tapCandidate.id === e.pointerId) {
      const dt = performance.now() - tapCandidate.t;
      const dx = Math.abs(e.clientX - tapCandidate.x);
      const dy = Math.abs(e.clientY - tapCandidate.y);
      const isTap = (dt < 260 && dx < 8 && dy < 8);
      if (isTap) handleTap(e.clientX, e.clientY, tapCandidate);
      tapCandidate = null;
    }

    if (state.pointers.size === 0) {
      canvas.style.cursor = "grab";
      state.dragStart = null;
      state.yDragStart = null;
      state.gestureStart = null;
      if (state.tool !== "cursor") state.cross.on = false;
    }

    if (state.pointers.size === 1) {
      state.gestureStart = null;
    }
  }
  canvas.addEventListener("pointerup", pointerUpCommon);
  canvas.addEventListener("pointercancel", pointerUpCommon);

  canvas.addEventListener("dblclick", (e) => {
    e.preventDefault();
    state.y.auto = !state.y.auto;
    $("autoY").checked = state.y.auto;
    if (state.y.auto) { state.y.scale = 1.0; state.y.offset = 0.0; }
  });

  // ===== UI handlers
  function buyMarket(){ marketOrder("buy", getQty(), getSlip()); }
  function sellMarket(){ marketOrder("sell", getQty(), getSlip()); }

  $("buyMkt").addEventListener("click", buyMarket);
  $("sellMkt").addEventListener("click", sellMarket);
  $("buyMktTop").addEventListener("click", buyMarket);
  $("sellMktTop").addEventListener("click", sellMarket);

  $("followWrap").addEventListener("click", (e) => {
    if (e.target.tagName !== "INPUT") $("follow").checked = !$("follow").checked;
    state.view.follow = $("follow").checked;

    const all = getAllBarsForRender();
    const last = Math.max(0, all.length - 1);
    const maxEnd = last + state.view.futureBars;

    if (state.view.follow) {
      state.view.end = maxEnd;
    } else {
      state.view.end = clamp(state.view.end, Math.max(0, state.view.visibleBars - 1), maxEnd);
    }
  });

  $("autoYWrap").addEventListener("click", (e) => {
    if (e.target.tagName !== "INPUT") $("autoY").checked = !$("autoY").checked;
    state.y.auto = $("autoY").checked;
    if (state.y.auto) { state.y.scale = 1.0; state.y.offset = 0.0; }
  });

  $("tool").addEventListener("change", () => {
    state.tool = $("tool").value;
    state.pending = null;
    if (state.tool === "cursor") state.cross.on = true;
  });

  $("undo").addEventListener("click", () => { if (state.pending) state.pending=null; else state.drawings.pop(); });
  $("clearDraw").addEventListener("click", () => { state.pending=null; state.drawings=[]; });

  $("placeLimit").addEventListener("click", () => {
    const side = $("limitSide").value;
    const price = Number($("limitPrice").value || 0);
    if (!Number.isFinite(price) || price <= 0) { toast("Enter a valid limit price"); return; }
    placeLimit(side, price, getQty());
  });

  $("placeLadder").addEventListener("click", () => {
    const side = $("ladderSide").value;
    const levels = Math.max(1, Math.floor(Number($("ladderLevels").value || 1)));
    const step = Number($("ladderStep").value || state.tickSize);
    const qtyPer = Math.max(1, Math.floor(Number($("ladderQty").value || 1)));
    let start = Number($("ladderStart").value || 0);
    if (!Number.isFinite(start) || start <= 0) { start = state.sim.price; $("ladderStart").value = start.toFixed(decimalsFor(state.tickSize)); }
    placeLadder(side, start, levels, step, qtyPer);
  });

  $("cancelAll").addEventListener("click", cancelAll);
  $("flatten").addEventListener("click", flatten);

  $("pause").addEventListener("click", () => {
    state.paused = !state.paused;
    $("pause").textContent = state.paused ? "‚ñ∂ Resume" : "‚è∏ Pause";
    toast(state.paused ? "Paused" : "Running");
  });

  $("stepTick").addEventListener("click", () => {
    if (!state.paused) { toast("Pause first to step"); return; }
    stepSimulationOnce();
  });

  // Speed
  document.querySelectorAll(".speedBtn").forEach(btn => {
    btn.addEventListener("click", () => {
      const v = Number(btn.dataset.speed || "1");
      state.speedMul = clamp(v, 0.1, 50);
      document.querySelectorAll(".speedBtn").forEach(b => b.classList.toggle("active", b === btn));
      toast(`Speed: ${state.speedMul}x`);
    });
  });

  // Vol preset
  $("volPreset").addEventListener("change", () => setVolPreset($("volPreset").value));

  // TF change
  $("timeframe").addEventListener("change", () => {
    const sec = Math.max(1, Number($("timeframe").value || 5));
    rebuildBars(sec);
  });

  // Indicators toggles
  ["indVol","indVwap","indMa"].forEach(id => {
    $(id).addEventListener("change", () => { applySettingsFromUI(); state.indCache.len = 0; });
  });

  // Drip trading
  function stopDrip() {
    if (state.drip.timer) clearInterval(state.drip.timer);
    state.drip.timer = null;
    state.drip.on = false;
    $("dripToggle").textContent = "‚ñ∂ Start Drip";
    toast("Drip stopped");
  }
  function startDrip() {
    stopDrip();
    const side = $("dripSide").value;
    const everySec = clamp(Number($("dripEvery").value || 2), 0.2, 999);
    const qtyEach = Math.max(1, Math.floor(Number($("dripQty").value || 1)));

    state.drip.on = true;
    state.drip.side = side;
    state.drip.timer = setInterval(() => {
      if (state.paused) return;
      marketOrder(side, qtyEach, getSlip());
    }, Math.round(everySec * 1000));

    $("dripToggle").textContent = "‚è∏ Drip Running";
    toast(`Drip ${side.toUpperCase()} every ${everySec}s`);
  }

  $("dripToggle").addEventListener("click", () => {
    if (state.drip.on) stopDrip();
    else startDrip();
  });
  $("dripStop").addEventListener("click", stopDrip);

  $("reset").addEventListener("click", () => {
    stopDrip();

    // reset sim
    state.sim.price = 17000;
    state.sim.drift = 0;
    state.sim.driftTarget = 0;
    state.sim.sigma = 3.2;
    state.sim.sigmaTarget = 3.2;
    state.sim.nextRegimeT = 30;
    state.sim.flow = 0;
    state.sim.vel = 0;

    // reset trading
    state.pos = 0;
    state.avg = null;
    state.limits = [];
    state.nextOrderId = 1;

    // reset drawings
    state.drawings = [];
    state.pending = null;

    // reset view
    $("follow").checked = true;
    state.view.follow = true;

    // reset y
    state.y.auto = true;
    $("autoY").checked = true;
    state.y.scale = 1.0;
    state.y.offset = 0.0;

    // reset history
    state.simTime = 0;
    state.tickCount = 0;
    state.ticks = [];
    state.bars = [];
    state.curBar = null;

    applySettingsFromUI();

    // warm-up
    const warmSeconds = 14 * 60;
    const baseHz = Math.max(20, state.p.simHzBase);
    const warmTicks = Math.floor(warmSeconds * baseHz);

    const savedPaused = state.paused;
    state.paused = true;
    for (let i=0;i<warmTicks;i++) stepSimulationOnce();
    state.paused = savedPaused;

    rebuildBars(state.tfSec);

    const dec = decimalsFor(state.tickSize);
    $("limitPrice").value = state.sim.price.toFixed(dec);
    $("ladderStart").value = state.sim.price.toFixed(dec);

    toast("Reset complete");
  });

  // Hotkeys
  window.addEventListener("keydown", (e) => {
    const tag = (document.activeElement && document.activeElement.tagName) || "";
    const typing = tag === "INPUT" || tag === "TEXTAREA" || tag === "SELECT";
    if (typing) return;

    const k = e.key.toLowerCase();

    if (k === "?") { e.preventDefault(); $("helpOverlay").classList.toggle("open"); return; }
    if (e.ctrlKey && k === "z") { e.preventDefault(); if (state.pending) state.pending=null; else state.drawings.pop(); return; }

    if (k === "b") { buyMarket(); return; }
    if (k === "s") { sellMarket(); return; }
    if (k === "f") {
      $("follow").checked = !$("follow").checked;
      state.view.follow = $("follow").checked;
      if (state.view.follow) {
        const all = getAllBarsForRender();
        state.view.end = Math.max(0, all.length - 1) + state.view.futureBars;
      }
      return;
    }
    if (k === " ") { e.preventDefault(); $("pause").click(); return; }
    if (k === "c") { cancelAll(); return; }
    if (k === "x") { flatten(); return; }
    if (k === "+") { setQty(getQty() + 1); return; }
    if (k === "-") { setQty(getQty() - 1); return; }

    if (k === "1") { $("tool").value="cursor"; $("tool").dispatchEvent(new Event("change")); return; }
    if (k === "2") { $("tool").value="trend";  $("tool").dispatchEvent(new Event("change")); return; }
    if (k === "3") { $("tool").value="rect";   $("tool").dispatchEvent(new Event("change")); return; }
    if (k === "4") { $("tool").value="hline";  $("tool").dispatchEvent(new Event("change")); return; }
    if (k === "5") { $("tool").value="erase";  $("tool").dispatchEvent(new Event("change")); return; }
  });

  // Help overlay
  const helpOverlay = $("helpOverlay");
  $("openHelp").addEventListener("click", () => helpOverlay.classList.add("open"));
  $("closeHelp").addEventListener("click", () => helpOverlay.classList.remove("open"));
  helpOverlay.addEventListener("click", (e) => { if (e.target === helpOverlay) helpOverlay.classList.remove("open"); });

  // init
  function init() {
    $("limitPrice").value = state.sim.price.toFixed(decimalsFor(state.tickSize));
    $("ladderStart").value = state.sim.price.toFixed(decimalsFor(state.tickSize));

    $("volPreset").value = state.volPresetKey;
    setVolPreset(state.volPresetKey);

    applySettingsFromUI();
    resizeCanvasToDisplaySize();

    // warm-up history
    const warmSeconds = 14 * 60;
    const baseHz = Math.max(20, state.p.simHzBase);
    const warmTicks = Math.floor(warmSeconds * baseHz);

    const savedPaused = state.paused;
    state.paused = true;
    for (let i=0;i<warmTicks;i++) stepSimulationOnce();
    state.paused = savedPaused;

    rebuildBars(state.tfSec);

    const all = getAllBarsForRender();
    state.view.end = Math.max(0, all.length - 1) + state.view.futureBars;

    toast("Ready");
  }

  let lastTs = performance.now();
  let acc = 0;

  function loop(ts) {
    const dt = (ts - lastTs) / 1000;
    lastTs = ts;

    applySettingsFromUI();

    // ticks per real second
    const ticksPerRealSec = Math.max(10, state.p.simHzBase * state.speedMul);
    const stepReal = 1 / ticksPerRealSec;

    if (!state.paused) {
      acc += dt;
      acc = Math.min(acc, 0.35);
      while (acc >= stepReal) {
        stepSimulationOnce();
        acc -= stepReal;
      }
    } else {
      // when paused, keep follow end consistent
      if (state.view.follow) {
        const all = getAllBarsForRender();
        state.view.end = Math.max(0, all.length - 1) + state.view.futureBars;
      }
    }

    drawChart();
    renderStats();
    requestAnimationFrame(loop);
  }

  init();
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
