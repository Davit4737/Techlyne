<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
  <title>TV-like Sandbox (Minimal)</title>
  <style>
    :root{
      --bg:#0b0f14; --text:#e7eef7; --muted:#9fb0c3; --line:#223044;
      --card: rgba(17,24,36,.75);
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, "Noto Sans", "Liberation Sans", sans-serif;
    }
    *{box-sizing:border-box}
    body{
      margin:0; font-family:var(--sans);
      background: radial-gradient(1200px 800px at 10% 10%, #101a2a 0%, var(--bg) 45%) fixed;
      color:var(--text);
      overflow:hidden; /* важно: чтобы page scroll не мешал пану */
    }

    .topbar{
      position:fixed; left:0; right:0; top:0;
      padding:10px 10px calc(10px + env(safe-area-inset-top));
      background: linear-gradient(180deg, rgba(17,24,36,.90), rgba(11,15,20,.55));
      border-bottom:1px solid rgba(34,48,68,.8);
      backdrop-filter: blur(8px);
      z-index:5;
    }
    .row{display:flex; gap:10px; align-items:center; flex-wrap:wrap;}
    .pill{
      display:inline-flex; gap:8px; align-items:center;
      padding:8px 10px;
      border-radius:999px;
      background: rgba(17,24,36,.75);
      border:1px solid rgba(34,48,68,.9);
      color:var(--muted);
      font-size:12px;
      white-space:nowrap;
    }
    .pill b{color:var(--text); font-weight:900}
    .btn{
      border:none; border-radius:12px; padding:9px 12px; cursor:pointer;
      font-weight:900; letter-spacing:.2px; user-select:none; white-space:nowrap;
      background: rgba(159,176,195,.12); color:#e7eef7; border:1px solid rgba(159,176,195,.35);
    }
    .btn:active{transform:translateY(1px)}
    .btn.good{background: rgba(61,220,151,.16); color:#bdf8de; border:1px solid rgba(61,220,151,.45);}
    .btn.bad{background: rgba(255,91,110,.14); color:#ffd0d7; border:1px solid rgba(255,91,110,.45);}
    .btn.neutral{background: rgba(100,181,255,.14); color:#d4ebff; border:1px solid rgba(100,181,255,.45);}
    .btn.warn{background: rgba(255,207,91,.12); color:#ffe8b2; border:1px solid rgba(255,207,91,.35);}

    select, input{
      background: rgba(11,15,20,.55);
      color: var(--text);
      border:1px solid rgba(34,48,68,.9);
      border-radius:12px;
      padding:8px 10px;
      font-weight:800;
      outline:none;
    }
    input{width:72px}
    select{max-width:220px}

    .hint{
      font-size:12px; color:var(--muted);
      padding:6px 10px;
      border-radius:12px;
      border:1px solid rgba(34,48,68,.7);
      background: rgba(11,15,20,.35);
      white-space:nowrap;
    }

    .wrap{
      position:fixed;
      left:0; right:0;
      top:72px; /* будет пересчитано JS-ом под высоту топбара */
      bottom:0;
      padding:10px 10px calc(10px + env(safe-area-inset-bottom));
    }

    canvas{
      width:100%;
      height:100%;
      display:block;
      border-radius:16px;
      border:1px solid rgba(34,48,68,.7);
      background: rgba(5,8,12,.65);
      touch-action:none; /* критично для пан/пинч */
      cursor:grab;
    }

    @media (max-width:520px){
      input{width:62px}
      .hint{display:none}
    }
  </style>
</head>
<body>

  <div class="topbar" id="topbar">
    <div class="row">
      <div class="pill">Инстр: <b id="sym">NQ (sim)</b></div>
      <div class="pill">Цена: <b id="hdrPrice">—</b></div>
      <div class="pill">Pos: <b id="hdrPos">0</b></div>

      <button class="btn good" id="buyMkt">Buy MKT</button>
      <button class="btn bad" id="sellMkt">Sell MKT</button>
      <div class="pill">qty <input id="qty" type="number" min="1" step="1" value="1"></div>
      <div class="pill">slip <input id="slip" type="number" min="0" step="1" value="1"></div>

      <div class="pill">TF
        <select id="timeframe">
          <option value="1s">1s</option>
          <option value="5s" selected>5s</option>
          <option value="15s">15s</option>
          <option value="1m">1m</option>
          <option value="5m">5m</option>
          <option value="15m">15m</option>
        </select>
      </div>

      <div class="pill">Tool
        <select id="tool">
          <option value="cursor" selected>Cursor</option>
          <option value="trend">Trend</option>
          <option value="rect">Rect</option>
          <option value="hline">HLine</option>
          <option value="erase">Erase</option>
        </select>
      </div>

      <button class="btn neutral" id="undo">Undo</button>
      <button class="btn neutral" id="clear">Clear</button>

      <button class="btn warn" id="follow">Auto-follow: ON</button>
      <button class="btn neutral" id="reset">Reset</button>

      <div class="hint">1 finger/drag=Pan • Pinch/Wheel=Zoom • Tap=Draw</div>
    </div>
  </div>

  <div class="wrap" id="wrap">
    <canvas id="chart"></canvas>
  </div>

<script>
(() => {
  const $ = (id)=>document.getElementById(id);
  const clamp=(x,a,b)=>Math.max(a,Math.min(b,x));
  const roundTo=(x,step)=>Math.round(x/step)*step;

  const state = {
    tickSize: 0.25,
    spreadTicks: 1,
    simHz: 60,

    volatility: 8,
    liquidity: 10,
    impact: 8,

    price: 17000,
    velocity: 0,
    flow: 0,
    flowDecay: 0.94,

    pos: 0,
    avg: null,

    // bars
    bars: [],
    _curBar: null,
    _barCounter: 0,
    barTicks: 300,
    lastBarIdx: 0,

    // view
    visibleBars: 140,
    rightOffset: 0,
    follow: true,

    // gesture
    pointers: new Map(),
    panStart: null,
    pinchStart: null,

    // crosshair
    cross: {on:false, x:0, y:0, idx:null, price:null},

    // drawings
    tool: "cursor",
    drawings: [],
    pending: null,

    // geometry cache
    geo: null
  };

  // ===== layout fix: set wrap top = topbar height
  function layout() {
    const topH = $("topbar").getBoundingClientRect().height;
    $("wrap").style.top = `${Math.ceil(topH)}px`;
  }
  window.addEventListener("resize", layout);

  // ===== canvas DPR resize (FIX "graph disappears")
  const canvas = $("chart");
  const ctx = canvas.getContext("2d");

  function resizeCanvasToDisplaySize() {
    const rect = canvas.getBoundingClientRect();
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    const w = Math.max(10, Math.floor(rect.width * dpr));
    const h = Math.max(10, Math.floor(rect.height * dpr));
    if (canvas.width !== w || canvas.height !== h) {
      canvas.width = w;
      canvas.height = h;
    }
  }

  function timeframeToBarTicks(tf, simHz) {
    if (tf==="1s") return Math.max(2, Math.round(1*simHz));
    if (tf==="5s") return Math.max(2, Math.round(5*simHz));
    if (tf==="15s") return Math.max(2, Math.round(15*simHz));
    if (tf==="1m") return Math.max(2, Math.round(60*simHz));
    if (tf==="5m") return Math.max(2, Math.round(300*simHz));
    if (tf==="15m") return Math.max(2, Math.round(900*simHz));
    return Math.max(2, Math.round(5*simHz));
  }

  function getBidAsk() {
    const spread = state.spreadTicks * state.tickSize;
    return { bid: state.price - spread/2, ask: state.price + spread/2 };
  }

  function applyFill(side, qty, fillPrice) {
    const oldPos = state.pos;
    const newPos = oldPos + (side==="buy"? qty : -qty);

    if (oldPos === 0) state.avg = fillPrice;
    else if (Math.sign(oldPos) === Math.sign(newPos) && newPos !== 0) {
      const oldAbs=Math.abs(oldPos), newAbs=Math.abs(newPos);
      const addQty=newAbs-oldAbs;
      if (addQty>0) state.avg = (state.avg*oldAbs + fillPrice*addQty)/newAbs;
    } else if (newPos === 0) state.avg = null;
    else if (Math.sign(oldPos) !== Math.sign(newPos)) state.avg = fillPrice;

    state.pos = newPos;
    state.flow += (side==="buy"? qty : -qty);
  }

  function marketOrder(side, qty, slipTicks) {
    const {bid, ask} = getBidAsk();
    const slip = slipTicks * state.tickSize;
    const fill = side==="buy" ? (ask + slip) : (bid - slip);
    applyFill(side, qty, fill);
  }

  function ensureCurBar() {
    if (!state._curBar) {
      state._curBar = { idx: state.lastBarIdx+1, o: state.price, h: state.price, l: state.price, c: state.price };
      state._barCounter = 0;
    }
  }

  function pushBar(bar) {
    state.lastBarIdx = bar.idx;
    state.bars.push(bar);
    if (state.bars.length > 8000) state.bars.shift();
  }

  function updateBarsWithPrice(p) {
    ensureCurBar();
    state._curBar.h = Math.max(state._curBar.h, p);
    state._curBar.l = Math.min(state._curBar.l, p);
    state._curBar.c = p;

    state._barCounter++;
    if (state._barCounter >= state.barTicks) {
      pushBar(state._curBar);
      state._curBar = { idx: state.lastBarIdx+1, o: p, h: p, l: p, c: p };
      state._barCounter = 0;
      if (state.follow) state.rightOffset = 0;
    }
  }

  function stepOnce() {
    state.flow *= state.flowDecay;

    const vol = clamp(state.volatility, 1, 20);
    const r = (Math.random()+Math.random()+Math.random()+Math.random()-2);
    const noise = r * (vol * state.tickSize * 0.18);

    const imp = clamp(state.impact, 0, 20);
    const liq = clamp(state.liquidity, 1, 20);
    const pressure = (state.flow) * (imp * state.tickSize * 0.045) * (1 / (liq * 0.40));

    state.velocity = (state.velocity * 0.92) + noise + pressure;
    state.price = roundTo(state.price + state.velocity, state.tickSize);

    updateBarsWithPrice(state.price);
  }

  // ===== prefill history (so "not from zero")
  function prefillHistory(nBars=400) {
    // временно делаем быстрый TF чтобы нагенерить бары
    const prevTicks = state.barTicks;
    state.barTicks = 10;

    for (let i=0;i<nBars*state.barTicks;i++){
      stepOnce();
    }

    // восстановим TF
    state.barTicks = prevTicks;
  }

  function getAllBars() {
    const arr = state.bars.slice();
    if (state._curBar) arr.push(state._curBar);
    return arr;
  }

  function getWindow() {
    const all = getAllBars();
    const n = all.length;
    if (n === 0) return {bars:[], start:0, end:0, total:0};
    const vis = clamp(state.visibleBars, 20, 600);
    const end = Math.max(0, n-1 - state.rightOffset);
    const start = Math.max(0, end - vis + 1);
    return { bars: all.slice(start, end+1), start, end, total:n };
  }

  function computeRange(bars) {
    let min=Infinity, max=-Infinity;
    for (const b of bars){ min=Math.min(min,b.l); max=Math.max(max,b.h); }
    if (!Number.isFinite(min) || !Number.isFinite(max) || min===max){
      min = state.price - 50*state.tickSize;
      max = state.price + 50*state.tickSize;
    }
    const pad = (max-min)*0.12 + state.tickSize*20;
    return { min:min-pad, max:max+pad };
  }

  function niceStep(range, target=8) {
    const raw = range / target;
    const pow = Math.pow(10, Math.floor(Math.log10(raw)));
    const frac = raw / pow;
    let nice;
    if (frac<=1) nice=1;
    else if (frac<=2) nice=2;
    else if (frac<=5) nice=5;
    else nice=10;
    return nice * pow;
  }

  function buildGeo(bars, pr) {
    const w=canvas.width, h=canvas.height;
    const leftPad=74, rightPad=14, topPad=10, bottomPad=26;
    const plotX0=leftPad, plotX1=w-rightPad, plotY0=topPad, plotY1=h-bottomPad;

    const n=bars.length;
    const candleW = Math.max(3, Math.floor((plotX1-plotX0)/(n+10)));
    const gap = Math.max(1, Math.floor(candleW*0.35));
    const step = candleW + gap;
    const totalW = step*n;
    const xStart = plotX0 + Math.max(6, Math.floor(((plotX1-plotX0)-totalW)/2));

    const yOf = (p) => {
      const yy = plotY1 - ((p-pr.min)/(pr.max-pr.min))*(plotY1-plotY0);
      return clamp(yy, plotY0, plotY1);
    };

    const rect = canvas.getBoundingClientRect();
    const stepPxScreen = step * (rect.width / canvas.width);

    // idx->x approx (for drawings)
    const firstIdx = bars[0].idx, lastIdx = bars[bars.length-1].idx;
    const xOfIdx = (idx) => {
      const span = Math.max(1, lastIdx-firstIdx);
      const t = (idx-firstIdx)/span;
      return plotX0 + t*(plotX1-plotX0);
    };

    return {w,h,leftPad,rightPad,topPad,bottomPad,plotX0,plotX1,plotY0,plotY1,candleW,gap,step,xStart,yOf,stepPxScreen,xOfIdx,firstIdx,lastIdx};
  }

  function canvasPtFromClient(e){
    const r=canvas.getBoundingClientRect();
    const x=(e.clientX-r.left)*(canvas.width/r.width);
    const y=(e.clientY-r.top)*(canvas.height/r.height);
    return {x,y};
  }

  function priceFromY(y, pr, geo){
    const t = (geo.plotY1 - y)/(geo.plotY1-geo.plotY0);
    const p = pr.min + t*(pr.max-pr.min);
    return roundTo(p, state.tickSize);
  }

  function idxFromX(x, win, geo){
    const n=win.bars.length;
    if (n<2) return null;
    const i = Math.round((x - geo.xStart)/geo.step);
    const ii=clamp(i,0,n-1);
    return win.bars[ii].idx;
  }

  function distPointToSegment(px,py,x1,y1,x2,y2){
    const dx=x2-x1, dy=y2-y1;
    if (dx===0 && dy===0) return Math.hypot(px-x1,py-y1);
    const t=((px-x1)*dx+(py-y1)*dy)/(dx*dx+dy*dy);
    const tt=clamp(t,0,1);
    const cx=x1+tt*dx, cy=y1+tt*dy;
    return Math.hypot(px-cx,py-cy);
  }

  function hitTest(pt, win, pr, geo){
    for (let k=state.drawings.length-1;k>=0;k--){
      const d=state.drawings[k];
      if (d.type==="hline"){
        const y=geo.yOf(d.p);
        if (Math.abs(pt.y-y)<=6 && pt.x>=geo.plotX0 && pt.x<=geo.plotX1) return k;
      }
      if (d.type==="trend"){
        const x1=geo.xOfIdx(d.x1), y1=geo.yOf(d.y1);
        const x2=geo.xOfIdx(d.x2), y2=geo.yOf(d.y2);
        if (distPointToSegment(pt.x,pt.y,x1,y1,x2,y2)<=7) return k;
      }
      if (d.type==="rect"){
        const x1=geo.xOfIdx(d.x1), x2=geo.xOfIdx(d.x2);
        const y1=geo.yOf(d.y1), y2=geo.yOf(d.y2);
        const l=Math.min(x1,x2), r=Math.max(x1,x2);
        const t=Math.min(y1,y2), b=Math.max(y1,y2);
        const onEdge =
          (Math.abs(pt.x-l)<=6 && pt.y>=t && pt.y<=b) ||
          (Math.abs(pt.x-r)<=6 && pt.y>=t && pt.y<=b) ||
          (Math.abs(pt.y-t)<=6 && pt.x>=l && pt.x<=r) ||
          (Math.abs(pt.y-b)<=6 && pt.x>=l && pt.x<=r);
        if (onEdge) return k;
      }
    }
    return -1;
  }

  function draw(){
    resizeCanvasToDisplaySize();
    const win = getWindow();
    const bars = win.bars;
    if (bars.length < 2) return;

    const pr = computeRange(bars);
    const geo = buildGeo(bars, pr);
    state.geo = geo;

    ctx.clearRect(0,0,geo.w,geo.h);

    // scale bg
    ctx.fillStyle="rgba(11,15,20,0.55)";
    ctx.fillRect(0,0,geo.leftPad,geo.h);

    // plot bg
    ctx.fillStyle="rgba(5,8,12,0.35)";
    ctx.fillRect(geo.plotX0,geo.plotY0,geo.plotX1-geo.plotX0,geo.plotY1-geo.plotY0);

    // separator
    ctx.strokeStyle="rgba(34,48,68,0.9)";
    ctx.lineWidth=1;
    ctx.beginPath(); ctx.moveTo(geo.leftPad+0.5,0); ctx.lineTo(geo.leftPad+0.5,geo.h); ctx.stroke();

    // price grid + labels
    let step = niceStep(pr.max-pr.min, 8);
    step = Math.max(state.tickSize, roundTo(step, state.tickSize));
    const startP = Math.floor(pr.min/step)*step;

    ctx.font = "12px " + getComputedStyle(document.body).fontFamily;
    ctx.textBaseline="middle";

    for (let p=startP; p<=pr.max+step; p+=step){
      const price = roundTo(p, state.tickSize);
      const y = geo.yOf(price);

      ctx.strokeStyle="rgba(34,48,68,0.45)";
      ctx.lineWidth=1;
      ctx.beginPath(); ctx.moveTo(geo.plotX0,y); ctx.lineTo(geo.plotX1,y); ctx.stroke();

      ctx.fillStyle="rgba(159,176,195,0.95)";
      ctx.fillText(price.toFixed(2), 8, y);
    }

    // vertical time grid light
    ctx.strokeStyle="rgba(34,48,68,0.35)";
    const stride = Math.max(5, Math.round(bars.length/10));
    for (let i=0;i<bars.length;i+=stride){
      const x = geo.xStart + i*geo.step + geo.candleW/2;
      ctx.beginPath(); ctx.moveTo(x,geo.plotY0); ctx.lineTo(x,geo.plotY1); ctx.stroke();
    }

    // bid/ask band
    const {bid, ask}=getBidAsk();
    const yBid=geo.yOf(bid), yAsk=geo.yOf(ask);
    ctx.fillStyle="rgba(159,176,195,0.08)";
    ctx.fillRect(geo.plotX0, Math.min(yBid,yAsk), geo.plotX1-geo.plotX0, Math.abs(yBid-yAsk));

    // candles
    for (let i=0;i<bars.length;i++){
      const b=bars[i];
      const x=geo.xStart + i*geo.step;
      const yO=geo.yOf(b.o), yH=geo.yOf(b.h), yL=geo.yOf(b.l), yC=geo.yOf(b.c);
      const up=b.c>=b.o;

      ctx.strokeStyle = up ? "rgba(61,220,151,0.85)" : "rgba(255,91,110,0.85)";
      ctx.lineWidth=1.5;
      ctx.beginPath(); ctx.moveTo(x+geo.candleW/2,yH); ctx.lineTo(x+geo.candleW/2,yL); ctx.stroke();

      const top=Math.min(yO,yC);
      const hh=Math.max(2, Math.abs(yC-yO));
      ctx.fillStyle = up ? "rgba(61,220,151,0.30)" : "rgba(255,91,110,0.28)";
      ctx.strokeStyle = up ? "rgba(61,220,151,0.95)" : "rgba(255,91,110,0.95)";
      ctx.fillRect(x,top,geo.candleW,hh);
      ctx.strokeRect(x,top,geo.candleW,hh);
    }

    // drawings
    for (const d of state.drawings){
      if (d.type==="hline"){
        const y=geo.yOf(d.p);
        ctx.strokeStyle="rgba(255,207,91,0.70)";
        ctx.lineWidth=1.6;
        ctx.beginPath(); ctx.moveTo(geo.plotX0,y); ctx.lineTo(geo.plotX1,y); ctx.stroke();
      }
      if (d.type==="trend"){
        const x1=geo.xOfIdx(d.x1), y1=geo.yOf(d.y1);
        const x2=geo.xOfIdx(d.x2), y2=geo.yOf(d.y2);
        ctx.strokeStyle="rgba(100,181,255,0.85)";
        ctx.lineWidth=2.0;
        ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();
      }
      if (d.type==="rect"){
        const x1=geo.xOfIdx(d.x1), x2=geo.xOfIdx(d.x2);
        const y1=geo.yOf(d.y1), y2=geo.yOf(d.y2);
        const l=Math.min(x1,x2), r=Math.max(x1,x2);
        const t=Math.min(y1,y2), b=Math.max(y1,y2);
        ctx.fillStyle="rgba(100,181,255,0.10)";
        ctx.strokeStyle="rgba(100,181,255,0.70)";
        ctx.lineWidth=1.8;
        ctx.fillRect(l,t,r-l,b-t);
        ctx.strokeRect(l,t,r-l,b-t);
      }
    }

    // pending preview
    if (state.pending && state.cross.idx!=null && state.cross.price!=null){
      ctx.save(); ctx.globalAlpha=0.9;
      if (state.pending.type==="trend"){
        const x1=geo.xOfIdx(state.pending.x1), y1=geo.yOf(state.pending.y1);
        const x2=geo.xOfIdx(state.cross.idx), y2=geo.yOf(state.cross.price);
        ctx.strokeStyle="rgba(100,181,255,0.55)";
        ctx.lineWidth=2;
        ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();
      }
      if (state.pending.type==="rect"){
        const x1=geo.xOfIdx(state.pending.x1), y1=geo.yOf(state.pending.y1);
        const x2=geo.xOfIdx(state.cross.idx), y2=geo.yOf(state.cross.price);
        const l=Math.min(x1,x2), r=Math.max(x1,x2);
        const t=Math.min(y1,y2), b=Math.max(y1,y2);
        ctx.fillStyle="rgba(100,181,255,0.06)";
        ctx.strokeStyle="rgba(100,181,255,0.45)";
        ctx.lineWidth=1.5;
        ctx.fillRect(l,t,r-l,b-t);
        ctx.strokeRect(l,t,r-l,b-t);
      }
      ctx.restore();
    }

    // last price label (left)
    const yLast=geo.yOf(state.price);
    ctx.fillStyle="rgba(100,181,255,0.20)";
    ctx.fillRect(0,yLast-12,geo.leftPad,24);
    ctx.strokeStyle="rgba(100,181,255,0.70)";
    ctx.lineWidth=1.2;
    ctx.strokeRect(0.5,yLast-11.5,geo.leftPad-1,23);
    ctx.fillStyle="rgba(211,236,255,0.98)";
    ctx.fillText(state.price.toFixed(2), 8, yLast);

    // crosshair
    if (state.cross.on && state.cross.idx!=null && state.cross.price!=null){
      const x=clamp(state.cross.x,geo.plotX0,geo.plotX1);
      const y=clamp(state.cross.y,geo.plotY0,geo.plotY1);

      ctx.strokeStyle="rgba(159,176,195,0.55)";
      ctx.lineWidth=1;
      ctx.setLineDash([4,4]);
      ctx.beginPath(); ctx.moveTo(geo.plotX0,y); ctx.lineTo(geo.plotX1,y); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(x,geo.plotY0); ctx.lineTo(x,geo.plotY1); ctx.stroke();
      ctx.setLineDash([]);

      // cross price label on left
      ctx.fillStyle="rgba(159,176,195,0.12)";
      ctx.fillRect(0,y-12,geo.leftPad,24);
      ctx.strokeStyle="rgba(159,176,195,0.55)";
      ctx.strokeRect(0.5,y-11.5,geo.leftPad-1,23);
      ctx.fillStyle="rgba(231,238,247,0.98)";
      ctx.fillText(state.cross.price.toFixed(2), 8, y);
    }
  }

  // ===== pan/zoom + tap draw
  function stepPxScreen(){ return state.geo ? Math.max(2,state.geo.stepPxScreen) : 8; }

  function setCrossFromClient(e){
    const win=getWindow();
    if (win.bars.length<2) return;
    const pr=computeRange(win.bars);
    const geo=state.geo || buildGeo(win.bars,pr);
    const pt=canvasPtFromClient(e);
    state.cross.x=pt.x; state.cross.y=pt.y;
    state.cross.idx=idxFromX(pt.x,win,geo);
    state.cross.price=priceFromY(pt.y,pr,geo);
    state.cross.on=true;
  }

  // wheel zoom
  canvas.addEventListener("wheel",(e)=>{
    e.preventDefault();
    const dir = e.deltaY>0 ? +1 : -1;
    const factor = (dir<0) ? 0.85 : 1.18;
    state.visibleBars = clamp(Math.round(state.visibleBars*factor), 20, 600);
    state.follow=false; $("follow").textContent="Auto-follow: OFF";
  },{passive:false});

  let tapCand=null;

  canvas.addEventListener("pointerdown",(e)=>{
    canvas.setPointerCapture(e.pointerId);
    state.pointers.set(e.pointerId,{x:e.clientX,y:e.clientY});

    tapCand={id:e.pointerId,x:e.clientX,y:e.clientY,t:performance.now()};

    // disable follow on interaction
    if (state.follow){ state.follow=false; $("follow").textContent="Auto-follow: OFF"; }

    if (state.pointers.size===1){
      canvas.style.cursor="grabbing";
      state.panStart={x:e.clientX, rightOffset: state.rightOffset, stepPx: stepPxScreen()};
      state.pinchStart=null;
      setCrossFromClient(e);
    } else if (state.pointers.size===2){
      const pts=[...state.pointers.values()];
      const dist=Math.hypot(pts[0].x-pts[1].x, pts[0].y-pts[1].y);
      state.pinchStart={dist, visibleBars: state.visibleBars};
      state.panStart=null;
      state.cross.on=false;
    }
  });

  canvas.addEventListener("pointermove",(e)=>{
    if (!state.pointers.has(e.pointerId)) return;
    state.pointers.set(e.pointerId,{x:e.clientX,y:e.clientY});

    // pinch zoom
    if (state.pointers.size===2 && state.pinchStart){
      const pts=[...state.pointers.values()];
      const dist=Math.hypot(pts[0].x-pts[1].x, pts[0].y-pts[1].y);
      const ratio=dist/Math.max(1,state.pinchStart.dist);
      state.visibleBars = clamp(Math.round(state.pinchStart.visibleBars/ratio),20,600);
      return;
    }

    // pan
    if (state.pointers.size===1 && state.panStart){
      const dx=e.clientX - state.panStart.x;
      const barsDelta=Math.round(-dx/Math.max(2,state.panStart.stepPx));
      state.rightOffset=Math.max(0, state.panStart.rightOffset + barsDelta);
    }

    // crosshair update
    setCrossFromClient(e);
  });

  function handleTap(clientX, clientY){
    const win=getWindow();
    if (win.bars.length<2) return;
    const pr=computeRange(win.bars);
    const geo=state.geo || buildGeo(win.bars,pr);
    const pt=canvasPtFromClient({clientX,clientY});

    if (pt.x<geo.plotX0 || pt.x>geo.plotX1 || pt.y<geo.plotY0 || pt.y>geo.plotY1) return;

    const idx=idxFromX(pt.x,win,geo);
    const price=priceFromY(pt.y,pr,geo);
    if (idx==null) return;

    if (state.tool==="erase"){
      const k=hitTest(pt,win,pr,geo);
      if (k>=0) state.drawings.splice(k,1);
      state.pending=null;
      return;
    }

    if (state.tool==="hline"){
      state.drawings.push({type:"hline", p: price});
      state.pending=null;
      return;
    }

    if (state.tool==="trend"){
      if (!state.pending) state.pending={type:"trend", x1: idx, y1: price};
      else { state.drawings.push({type:"trend", x1:state.pending.x1,y1:state.pending.y1,x2:idx,y2:price}); state.pending=null; }
      return;
    }

    if (state.tool==="rect"){
      if (!state.pending) state.pending={type:"rect", x1: idx, y1: price};
      else { state.drawings.push({type:"rect", x1:state.pending.x1,y1:state.pending.y1,x2:idx,y2:price}); state.pending=null; }
      return;
    }
  }

  function pointerUpCommon(e){
    if (state.pointers.has(e.pointerId)) state.pointers.delete(e.pointerId);

    if (tapCand && tapCand.id===e.pointerId){
      const dt=performance.now()-tapCand.t;
      const dx=Math.abs(e.clientX-tapCand.x);
      const dy=Math.abs(e.clientY-tapCand.y);
      if (dt<260 && dx<8 && dy<8) handleTap(e.clientX,e.clientY);
      tapCand=null;
    }

    if (state.pointers.size===0){
      canvas.style.cursor="grab";
      state.panStart=null;
      state.pinchStart=null;
    } else if (state.pointers.size===1){
      const only=[...state.pointers.values()][0];
      state.panStart={x:only.x, rightOffset: state.rightOffset, stepPx: stepPxScreen()};
      state.pinchStart=null;
    }
  }
  canvas.addEventListener("pointerup", pointerUpCommon);
  canvas.addEventListener("pointercancel", pointerUpCommon);

  // ===== UI
  function refreshHeader(){
    $("hdrPrice").textContent = state.price.toFixed(2);
    $("hdrPos").textContent = String(state.pos);
  }

  function clampOffset(){
    const n=getAllBars().length;
    if (n<=1){ state.rightOffset=0; return; }
    state.rightOffset = clamp(state.rightOffset, 0, Math.max(0,n-1));
  }

  function getQty(){ return Math.max(1, Math.floor(Number($("qty").value||1))); }
  function getSlip(){ return Math.max(0, Math.floor(Number($("slip").value||0))); }

  $("buyMkt").addEventListener("click", ()=>marketOrder("buy", getQty(), getSlip()));
  $("sellMkt").addEventListener("click", ()=>marketOrder("sell", getQty(), getSlip()));

  $("tool").addEventListener("change", ()=>{
    state.tool=$("tool").value;
    state.pending=null;
  });

  $("undo").addEventListener("click", ()=>{
    if (state.pending) { state.pending=null; return; }
    state.drawings.pop();
  });

  $("clear").addEventListener("click", ()=>{
    state.pending=null;
    state.drawings=[];
  });

  $("follow").addEventListener("click", ()=>{
    state.follow = !state.follow;
    if (state.follow) state.rightOffset=0;
    $("follow").textContent = state.follow ? "Auto-follow: ON" : "Auto-follow: OFF";
  });

  $("reset").addEventListener("click", ()=>{
    state.price=17000; state.velocity=0; state.flow=0;
    state.pos=0; state.avg=null;

    state.bars=[]; state._curBar=null; state._barCounter=0; state.lastBarIdx=0;
    state.rightOffset=0; state.visibleBars=140;

    state.drawings=[]; state.pending=null;
    state.follow=true; $("follow").textContent="Auto-follow: ON";

    // re-apply tf
    state.barTicks = timeframeToBarTicks($("timeframe").value, state.simHz);
    prefillHistory(400);
  });

  $("timeframe").addEventListener("change", ()=>{
    state.barTicks = timeframeToBarTicks($("timeframe").value, state.simHz);
  });

  // ===== main loop
  let lastTs=performance.now(), acc=0;

  function loop(ts){
    const dt=(ts-lastTs)/1000; lastTs=ts;

    // if follow -> keep at live
    if (state.follow) state.rightOffset=0;

    // simulate
    acc += dt;
    const step=1/state.simHz;
    acc = Math.min(acc, 0.25);
    while (acc>=step){
      stepOnce();
      acc-=step;
    }

    clampOffset();
    refreshHeader();
    draw();

    requestAnimationFrame(loop);
  }

  // ===== start
  layout();
  state.barTicks = timeframeToBarTicks($("timeframe").value, state.simHz);
  prefillHistory(400); // сразу история
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
