<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Crypto Sandbox — Long & Short, Liquidation, Sim</title>
<!-- Lightweight Charts (TradingView-like) -->
<script src="https://unpkg.com/lightweight-charts@3.8.0/dist/lightweight-charts.standalone.production.js"></script>
<style>
:root{
  --bg:#08101a; --panel:#0c1722; --muted:#9fb0d3; --up:#2ecc71; --down:#ff5b5b; --accent:#00c1ff;
}
*{box-sizing:border-box}
body{margin:0;font-family:Inter,Arial,Helvetica,sans-serif;background:var(--bg);color:#e8f4ff}
.wrap{max-width:1280px;margin:12px auto;padding:12px}
.header{display:flex;justify-content:space-between;align-items:center;margin-bottom:8px}
.title{font-weight:800}
.grid{display:grid;grid-template-columns:1fr 380px;gap:12px}
.panel{background:linear-gradient(180deg,var(--panel),#06121a);padding:12px;border-radius:10px;box-shadow:0 8px 30px rgba(0,0,0,0.6)}
.tools{display:flex;gap:6px;flex-wrap:wrap;margin-bottom:8px}
.btn{border:0;border-radius:8px;padding:8px 10px;background:#0b1520;color:#e8f4ff;cursor:pointer;font-weight:700}
.btn.primary{background:linear-gradient(90deg,#1b7bff,#00c1ff)}
.btn.danger{background:linear-gradient(90deg,#ff5b5b,#ff9a5b)}
.small{font-size:13px;color:var(--muted)}
.row{display:flex;gap:8px;align-items:center}
.input, select{border-radius:8px;padding:8px;border:0;background:#07121a;color:#e8f4ff}
.canvas{height:520px;border-radius:8px;overflow:hidden}
.stat-grid{display:grid;grid-template-columns:repeat(2,1fr);gap:8px;margin-top:10px}
.stat{background:rgba(255,255,255,0.02);padding:8px;border-radius:8px;text-align:center}
.table{width:100%;border-collapse:collapse;font-size:13px;margin-top:8px}
.table th,.table td{padding:6px 8px;border-bottom:1px solid rgba(255,255,255,0.04)}
.table th{color:var(--muted);font-weight:700}
.bad{color:#ff8b8b}.ok{color:#7ef29a}
.controls-block{background:rgba(255,255,255,0.01);padding:8px;border-radius:8px;margin-top:8px}
.footer{margin-top:10px;font-size:12px;color:var(--muted)}
.smallinput{width:100px;padding:6px;border-radius:6px;border:0;background:#07121a;color:#e8f4ff}
</style>
</head>
<body>
<div class="wrap">
  <div class="header">
    <div>
      <div class="title">Crypto Sandbox — Long / Short / Liquidation (sim)</div>
      <div class="small">Горячие клавиши: B=Buy(long) · S=Sell/Close long · Shift+S=Open short · H=hand-move (режим рисования отключён)</div>
    </div>
    <div class="small">Никаких надписей прямо на свечах — только аккуратные ценовые линии</div>
  </div>

  <div class="grid">
    <!-- Left: chart -->
    <div class="panel">
      <div class="tools">
        <select id="mode" class="input">
          <option value="candles">Candles</option>
          <option value="line">Line</option>
          <option value="area">Area</option>
        </select>
        <select id="tf" class="input">
          <option value="1">1s</option><option value="5" selected>5s</option><option value="15">15s</option>
          <option value="60">1m</option><option value="300">5m</option><option value="900">15m</option>
          <option value="3600">1h</option><option value="86400">1d</option>
        </select>

        <div style="flex:1"></div>

        <div class="small" style="align-self:center">Leverage</div>
        <select id="leverage" class="input" style="max-width:90px">
          <option>1</option><option>2</option><option selected>5</option><option>10</option><option>25</option><option>50</option>
        </select>
      </div>

      <div id="chart" class="canvas"></div>

      <div class="row" style="margin-top:8px;align-items:center">
        <div class="small">Price: <b id="price">$—</b></div>
        <div style="width:16px"></div>
        <div class="small">Unrealized PnL: <b id="upnl">$0 (0%)</b></div>
        <div style="flex:1"></div>

        <input id="orderSize" type="number" value="100" min="1" class="smallinput" />
        <button id="openLong" class="btn primary">Open Long</button>
        <button id="openShort" class="btn danger">Open Short</button>
        <button id="closePos" class="btn">Close (FIFO)</button>
      </div>

      <div class="controls-block">
        <div class="row" style="gap:12px">
          <label class="small">Liquidity (A reserve):</label>
          <input id="liquidity" type="range" min="200" max="200000" step="50" value="10000" style="flex:1">
          <span id="liqVal" class="small">10000</span>
        </div>
        <div class="row" style="gap:12px;margin-top:6px">
          <label class="small">Supply (tokens):</label>
          <input id="supply" type="number" class="smallinput" value="100000">
          <label class="small" style="margin-left:12px">Manual price (for testing):</label>
          <input id="priceManual" type="range" min="0.0001" max="10" step="0.0001" value="1" style="flex:1">
          <span id="pmVal" class="small">1.0000</span>
        </div>
      </div>

      <div class="footer">Как открыть Short: нажми <b>Open Short</b> или удерживай Shift+S. Позиции показываются как ценовые линии. Линии показывают цену входа + PnL в тултипе.</div>
    </div>

    <!-- Right: controls & positions -->
    <div class="panel">
      <div class="col">
        <div class="stat-grid">
          <div class="stat"><div class="small">Market Cap</div><b id="mcap">—</b></div>
          <div class="stat"><div class="small">Supply</div><b id="supplyVal">100000</b></div>
        </div>

        <div style="margin-top:10px">
          <div class="small">Open positions</div>
          <table class="table" id="posTable">
            <thead><tr><th>#</th><th>Side</th><th>Size ($)</th><th>Entry</th><th>Qty</th><th>UPnL $</th><th>UPnL %</th><th>LiQ</th></tr></thead>
            <tbody></tbody>
          </table>
        </div>

        <div style="margin-top:10px">
          <div class="small">Realized PnL: <b id="rpnl">$0.00</b></div>
          <div class="small" style="margin-top:6px">Trade log</div>
          <table class="table" id="txTable"><thead><tr><th>Time</th><th>Side</th><th>Size $</th><th>Price</th></tr></thead><tbody></tbody></table>
        </div>

        <div style="margin-top:10px" class="controls-block">
          <div class="row">
            <label class="small">Time multiplier:</label>
            <input id="timeMult" type="range" min="1" max="200000" value="1500" style="flex:1">
            <span id="tmVal" class="small">1500x</span>
          </div>
          <div class="row" style="margin-top:6px">
            <label class="small">Market activity (trades per candle):</label>
            <input id="activity" type="range" min="0" max="50" value="4" style="flex:1">
            <span id="actVal" class="small">4</span>
          </div>
        </div>

      </div>
    </div>
  </div>
</div>

<script>
/*
Crypto Sandbox — single-file implementation
Features:
- Lightweight-charts candlesticks
- Open Long / Open Short positions (isolated margin simulation)
- Position entries shown as price lines; UPnL and liquidation price displayed
- Manual controls: liquidity, supply, manual price slider (for tests)
- Test buys/sells via AMM affect simulated price
- No textual labels on candles themselves
*/

// Short notes: This is a simulation tool. Liquidation formula is a simple isolated-margin model:
//   maintenance = 0.005 (0.5%); leverage L => approx liq_long = entry * (1 - (1 / L) + maintenance)
//   liq_short = entry * (1 + (1 / L) - maintenance)
// It's not an exchange-grade calc — purely for demo/visualization.

const lc = window.LightweightCharts;

// DOM refs
const chartEl = document.getElementById('chart');
const modeSel = document.getElementById('mode');
const tfSel = document.getElementById('tf');
const orderSizeEl = document.getElementById('orderSize');
const openLongBtn = document.getElementById('openLong');
const openShortBtn = document.getElementById('openShort');
const closePosBtn = document.getElementById('closePos');
const priceEl = document.getElementById('price');
const upnlEl = document.getElementById('upnl');
const posTableBody = document.querySelector('#posTable tbody');
const txTbody = document.querySelector('#txTable tbody');
const rpnlEl = document.getElementById('rpnl');

const liqRange = document.getElementById('liquidity'), liqVal = document.getElementById('liqVal');
const supplyInput = document.getElementById('supply'), supplyVal = document.getElementById('supplyVal');
const pmRange = document.getElementById('priceManual'), pmVal = document.getElementById('pmVal');

const timeMultRange = document.getElementById('timeMult'), tmVal = document.getElementById('tmVal');
const activityRange = document.getElementById('activity'), actVal = document.getElementById('actVal');
const leverageSel = document.getElementById('leverage');

let maintenance = 0.005; // 0.5% maintenance margin for liq calc

// Chart init
const chart = lc.createChart(chartEl, {
  width: chartEl.clientWidth,
  height: chartEl.clientHeight,
  layout: { background: { type: lc.ColorType.Solid, color: '#08101a' }, textColor: '#e8f4ff' },
  grid: { vertLines:{color:'#0f1a23'}, horzLines:{color:'#0f1a23'} },
  rightPriceScale:{ borderColor:'#0f1a23' }, timeScale:{ borderColor:'#0f1a23' }
});
const candleSeries = chart.addCandlestickSeries({ upColor:'#2ecc71', downColor:'#ff5b5b', wickVisible:true, borderVisible:false });
const lineSeries = chart.addLineSeries({ color:'#2ecc71', visible:false });

// Resize handling
window.addEventListener('resize', ()=> chart.applyOptions({ width: chartEl.clientWidth, height: chartEl.clientHeight }));

// Simulation state (AMM-ish)
let liquidity = Number(liqRange.value);
liquidity = Math.max(1, liquidity);
let reserveA = liquidity, reserveB = liquidity;
let k = reserveA * reserveB;
let supply = Number(supplyInput.value);
let price = 1.0;
let virtualNow = Date.now();
let tfSec = Number(tfSel.value);
let timeMultiplier = Number(timeMultRange.value);
let activity = Number(activityRange.value);
let lastReal = performance.now();
let accMs = 0;
const MAX_CANDLES = 600;

liqVal.textContent = liquidity;
supplyVal.textContent = supply;
pmVal.textContent = (1.0).toFixed(4);
tmVal.textContent = timeMultiplier + 'x';
actVal.textContent = activity;

// Candles history
let candles = [];
let currentCandle = null;
function seed(){
  let p = 1.0;
  const start = virtualNow - 180*tfSec*1000;
  for(let i=0;i<180;i++){
    const t = Math.floor((start + i*tfSec*1000)/1000);
    const o = +(p*(1 + (Math.random()-0.5)*0.006));
    const c = +(o*(1 + (Math.random()-0.5)*0.006));
    const h = Math.max(o,c)*(1 + Math.random()*0.004);
    const l = Math.min(o,c)*(1 - Math.random()*0.004);
    candles.push({ time: t, open: o, high: h, low: l, close: c });
    p = c;
  }
  currentCandle = { time: Math.floor(virtualNow/1000), open: p, high:p, low:p, close:p };
  price = p;
  candleSeries.setData(candles);
}
seed();

// utility: AMM constant product swap (simple)
function recalcK(){ k = reserveA * reserveB; price = reserveA / reserveB; }
function buyBase(amountBase){ // you give base A to buy token B: A increases, B decreases
  if(amountBase <= 0) return 0;
  const A = reserveA, B = reserveB;
  const newA = A + amountBase;
  const newB = k / newA;
  const tokensOut = B - newB;
  if(!isFinite(tokensOut) || tokensOut <= 0) return 0;
  reserveA = newA; reserveB = newB; recalcK();
  return tokensOut;
}
function sellToken(amountToken){ // you sell token B to get base A
  if(amountToken <= 0) return 0;
  const A = reserveA, B = reserveB;
  const newB = B + amountToken;
  const newA = k / newB;
  const baseOut = A - newA;
  if(!isFinite(baseOut) || baseOut <= 0) return 0;
  reserveA = newA; reserveB = newB; recalcK();
  return baseOut;
}

// update visuals
function updateCandleLive(){
  currentCandle.close = price;
  currentCandle.high = Math.max(currentCandle.high, price);
  currentCandle.low = Math.min(currentCandle.low, price);
  candleSeries.update(currentCandle);
  lineSeries.update({ time: currentCandle.time, value: currentCandle.close });
}

// Positions & PnL
// We'll simulate isolated positions with chosen leverage L and size in $ (not margin).  
// For long: qty = size / entryPrice. Unrealized PnL = (price - entry)*qty.
// For short: qty = size / entryPrice (we treat as borrowed notional). Unrealized PnL = (entry - price)*qty.
// Liquidation (simple isolated model): liq_long = entry*(1 - (1/L) + maintenance), liq_short = entry*(1 + (1/L) - maintenance)
let openPositions = []; // { id, side:'long'|'short', sizeUSD, entryPrice, qty, leverage, entryTime, priceLine }
let realizedPnL = 0;
let nextPosId = 1;

function openPosition(side, sizeUSD, leverage){
  const entry = price;
  const qty = sizeUSD / entry; // token units (base not used)
  const id = nextPosId++;
  const pos = { id, side, sizeUSD, entryPrice: entry, qty, leverage, entryTime: Date.now(), priceLine:null };
  // create price line
  const color = side==='long' ? '#00c1ff' : '#ff9a8a';
  pos.priceLine = candleSeries.createPriceLine({ price: entry, color: color, lineWidth:1, axisLabelVisible:true, title: `${side.toUpperCase()} #${id} ${entry.toFixed(4)}` });
  openPositions.push(pos);
  pushTx(side==='long' ? 'OPEN LONG' : 'OPEN SHORT', sizeUSD, entry);
  updatePositionsUI();
}

function closePositionFIFO(sizeUSD){
  // Close using FIFO: reduce openPositions from start
  let toCloseUSD = sizeUSD;
  while(toCloseUSD > 0 && openPositions.length){
    const pos = openPositions[0];
    const posValue = pos.qty * price; // current notional
    const closeUSD = Math.min(toCloseUSD, pos.sizeUSD);
    // proportion of the position being closed:
    const frac = closeUSD / pos.sizeUSD;
    const qtyClose = pos.qty * frac;
    // PnL for quantity closed:
    let pnl = 0;
    if(pos.side === 'long') pnl = (price - pos.entryPrice) * qtyClose;
    else pnl = (pos.entryPrice - price) * qtyClose;
    realizedPnL += pnl;
    // shrink position
    pos.sizeUSD -= closeUSD;
    pos.qty -= qtyClose;
    if(pos.sizeUSD <= 1e-8 || pos.qty <= 1e-12){
      // remove
      try{ candleSeries.removePriceLine(pos.priceLine); }catch(e){}
      openPositions.shift();
    } else {
      // update price line title
      try{ candleSeries.removePriceLine(pos.priceLine); }catch(e){}
      const color2 = pos.side==='long' ? '#00c1ff' : '#ff9a8a';
      pos.priceLine = candleSeries.createPriceLine({ price: pos.entryPrice, color: color2, lineWidth:1, axisLabelVisible:true, title:`${pos.side.toUpperCase()} #${pos.id} ${pos.entryPrice.toFixed(4)} • size $${pos.sizeUSD.toFixed(2)}` });
      break; // if we partially closed, stop
    }
    toCloseUSD -= closeUSD;
    updatePositionsUI();
  }
  updatePositionsUI();
  pushTx('CLOSE', sizeUSD, price);
}

// Helpers: PnL & liq calc
function computeUnrealized(pos){
  if(pos.side==='long'){
    const pnl = (price - pos.entryPrice) * pos.qty;
    const base = pos.entryPrice * pos.qty;
    const pct = base>0 ? (pnl / base * 100) : 0;
    // liquidation:
    const L = pos.leverage || 1;
    const liq = pos.entryPrice * (1 - (1 / L) + maintenance);
    return { pnl, pct, liq };
  } else {
    const pnl = (pos.entryPrice - price) * pos.qty;
    const base = pos.entryPrice * pos.qty;
    const pct = base>0 ? (pnl / base * 100) : 0;
    const L = pos.leverage || 1;
    const liq = pos.entryPrice * (1 + (1 / L) - maintenance);
    return { pnl, pct, liq };
  }
}

// UI update
function updatePositionsUI(){
  // table
  posTableBody.innerHTML = '';
  openPositions.forEach((pos, idx)=>{
    const u = computeUnrealized(pos);
    const tr = document.createElement('tr');
    tr.innerHTML = `<td>${pos.id}</td><td>${pos.side}</td><td>$${pos.sizeUSD.toFixed(2)}</td><td>$${pos.entryPrice.toFixed(6)}</td>
      <td>${pos.qty.toFixed(6)}</td>
      <td style="color:${u.pnl>=0? '#7ef29a':'#ff8b8b'}">${u.pnl.toFixed(2)}</td>
      <td style="color:${u.pct>=0? '#7ef29a':'#ff8b8b'}">${u.pct.toFixed(2)}%</td>
      <td>$${u.liq.toFixed(6)}</td>`;
    posTableBody.appendChild(tr);
    // update price line title with real-time PnL
    try{ candleSeries.removePriceLine(pos.priceLine); }catch(e){}
    const color2 = pos.side==='long' ? '#00c1ff' : '#ff9a8a';
    pos.priceLine = candleSeries.createPriceLine({
      price: pos.entryPrice,
      color: color2,
      lineWidth: 1,
      axisLabelVisible: true,
      title: `${pos.side.toUpperCase()} #${pos.id} ${pos.entryPrice.toFixed(4)} • UPnL ${u.pnl>=0?'+':''}${u.pnl.toFixed(2)}$`
    });
  });
  // UPnL badge
  let totUnreal = 0, base=0;
  openPositions.forEach(p => { const u = computeUnrealized(p); totUnreal += u.pnl; base += p.entryPrice * p.qty; });
  upnlEl.textContent = `${totUnreal>=0?'+':''}$${totUnreal.toFixed(2)} (${base>0? ((totUnreal/base*100).toFixed(2)+'%') : '0%'})`;
  upnlEl.style.color = totUnreal>=0 ? '#7ef29a' : '#ff8b8b';
  rpnlEl.textContent = (realizedPnL>=0?'+':'') + '$' + realizedPnL.toFixed(2);
}

// Transaction log
function pushTx(side, size, p){
  const tr = document.createElement('tr');
  tr.innerHTML = `<td>${new Date().toLocaleTimeString()}</td><td style="color:${side.includes('LONG')||side==='OPEN LONG'?'#7ef29a':'#ff8b8b'}">${side}</td><td>$${Number(size).toFixed(2)}</td><td>$${p.toFixed(6)}</td>`;
  txTbody.prepend(tr);
  while(txTbody.children.length>300) txTbody.removeChild(txTbody.lastChild);
}

// Controls wiring
liquidationChange = () => {
  liquidity = Number(liqRange.value); liqVal.textContent = liquidity; reserveA = liquidity; reserveB = liquidity / price; recalcK(); updateDepth();
};
liqRange.addEventListener('input', liquidationChange);

supplyInput.addEventListener('input', ()=>{
  supply = Number(supplyInput.value); supplyVal.textContent = supply;
  updateMcap();
});

pmRange.addEventListener('input', ()=>{
  const manualP = Number(pmRange.value);
  price = manualP;
  pmVal.textContent = manualP.toFixed(4);
  reserveB = k / reserveA; recalcK();
  updateCandleLive();
  updatePositionsUI();
  updateMcap();
});
tfSel.addEventListener('change', ()=> tfSec = Number(tfSel.value));
modeSel.addEventListener('change', ()=>{
  const v = modeSel.value;
  if(v==='candles'){ candleSeries.applyOptions({ visible:true }); lineSeries.applyOptions({ visible:false }); }
  else { candleSeries.applyOptions({ visible:false }); lineSeries.applyOptions({ visible:true }); lineSeries.setData(candles.concat([currentCandle]).map(c=>({time:c.time, value:c.close}))); }
});

timeMultRange.addEventListener('input', ()=>{ timeMultiplier = Number(timeMultRange.value); tmVal.textContent = timeMultiplier + 'x'; });
activityRange.addEventListener('input', ()=>{ activity = Number(activityRange.value); actVal.textContent = activity; });

// Depth update (synthetic)
function updateDepth(){
  // not displayed separately, but we keep reserves consistent
  reserveB = k / reserveA;
  recalcK();
}

// Open/close handlers
openLongBtn.addEventListener('click', ()=>{
  const size = Math.max(0, Number(orderSizeEl.value) || 0);
  const L = Number(leverageSel.value)||1;
  if(size <= 0) return alert('Введите размер позиции > 0');
  openPosition('long', size, L);
  updatePositionsUI();
});
openShortBtn.addEventListener('click', ()=>{
  const size = Math.max(0, Number(orderSizeEl.value) || 0);
  const L = Number(leverageSel.value)||1;
  if(size <= 0) return alert('Введите размер позиции > 0');
  openPosition('short', size, L);
  updatePositionsUI();
});
closePosBtn.addEventListener('click', ()=>{
  const size = Math.max(0, Number(orderSizeEl.value) || 0);
  if(size <= 0) return alert('Введите размер закрытия > 0');
  closePositionFIFO(size);
  updatePositionsUI();
});

// keyboard: B opens long, Shift+S opens short, S closes (sell)
document.addEventListener('keydown', (e)=>{
  if(e.key === 'b' || e.key === 'B') openLongBtn.click();
  if((e.key === 's' || e.key === 'S') && e.shiftKey) openShortBtn.click();
  else if(e.key === 's' || e.key === 'S') closePosBtn.click();
});

// Engine: price evolution + AMM trades for activity
function microNoise(){
  // small random walk plus occasional shock
  const drift = (Math.random()-0.5) * 0.0006;
  const shock = Math.random() < 0.02 ? (Math.random()-0.5) * 0.03 : 0;
  price = Math.max(0.0000001, price * (1 + drift + shock));
}

// simulate random trades that affect AMM slightly
function randomAMMEvent(){
  if(Math.random() < 0.5){
    const amt = Math.random() * reserveA * (0.0005 + Math.random() * 0.01);
    buyBase(amt);
  } else {
    const t = Math.random() * reserveB * (0.0005 + Math.random() * 0.01);
    sellToken(t);
  }
  // update internal price (reserveA/reserveB)
  recalcK();
  price = reserveA / reserveB;
}

// finalize candle
function finalizeCandle(){
  candles.push({ time: currentCandle.time, open: currentCandle.open, high: currentCandle.high, low: currentCandle.low, close: currentCandle.close });
  if(candles.length > MAX_CANDLES) candles.shift();
  currentCandle = { time: Math.floor(virtualNow/1000), open: price, high: price, low: price, close: price };
  candleSeries.setData(candles.concat([currentCandle]));
  lineSeries.setData(candles.concat([currentCandle]).map(c=>({time:c.time, value:c.close})));
}

// engine loop
function engineLoop(){
  const now = performance.now();
  const dt = Math.max(0, now - lastReal);
  lastReal = now;
  const dv = dt * timeMultiplier;
  virtualNow += dv;
  accMs += dv;

  // live price walk
  microNoise();

  // small AMM noise occasionally
  if(Math.random() < 0.15) randomAMMEvent();

  // update current candle live
  currentCandle.close = price;
  currentCandle.high = Math.max(currentCandle.high, price);
  currentCandle.low = Math.min(currentCandle.low, price);
  candleSeries.update(currentCandle);
  lineSeries.update({ time: currentCandle.time, value: currentCandle.close });

  if(accMs >= tfSec * 1000){
    // simulate activity
    for(let i=0;i<activity;i++) randomAMMEvent();
    finalizeCandle();
    accMs = 0;
  }

  // refresh UI
  priceEl.textContent = '$' + price.toFixed(6);
  updatePositionsUI();
  updateMcap();

  requestAnimationFrame(engineLoop);
}
requestAnimationFrame(engineLoop);

// mcap
function updateMcap(){ document.getElementById('mcap').textContent = '$' + (price * supply).toFixed(2); }

// initial UI
updatePositionsUI();
updateMcap();
updateDepth();

// helper: openPosition uses openPosition above
function openPosition(side, sizeUSD, leverage){
  const entry = price;
  const qty = sizeUSD / entry;
  const id = nextPosId++;
  const pos = { id, side, sizeUSD, entryPrice: entry, qty, leverage, entryTime: Date.now(), priceLine: null };
  // show price line
  const color = side === 'long' ? '#00c1ff' : '#ff9a8a';
  pos.priceLine = candleSeries.createPriceLine({ price: entry, color: color, lineWidth: 1, axisLabelVisible: true, title: `${side.toUpperCase()} #${id} ${entry.toFixed(4)}` });
  openPositions.push(pos);
  pushTx(side==='long' ? 'OPEN LONG' : 'OPEN SHORT', sizeUSD, entry);
  updatePositionsUI();
  return pos;
}

// small defensive: ensure overlay labels not drawn on candles (we use price lines only)
// Done: we never set markers with text on candles.

// Final instructions (user-visible)
console.info('Sandbox loaded: B=open long, Shift+S=open short, S=close (FIFO). Use manual price slider or let engine run.');

// End of script
</script>
</body>
</html>
