<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Market Sandbox ‚Äî TV-like Chart (Improved)</title>
  <style>
    :root{
      --bg:#0b0f14; --text:#e7eef7; --muted:#9fb0c3; --line:#223044;
      --shadow: 0 10px 30px rgba(0,0,0,.35); --radius: 14px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, "Noto Sans", "Liberation Sans", sans-serif;
    }
    *{box-sizing:border-box}
    body{
      margin:0; font-family:var(--sans);
      background: radial-gradient(1200px 800px at 10% 10%, #101a2a 0%, var(--bg) 45%) fixed;
      color:var(--text);
    }

    header{
      padding:12px 16px;
      border-bottom:1px solid var(--line);
      background: linear-gradient(180deg, rgba(17,24,36,.88), rgba(11,15,20,.58));
      position:sticky; top:0; z-index:4;
      backdrop-filter: blur(8px);
    }
    header .row{
      display:flex; align-items:center; justify-content:space-between; gap:12px;
      max-width:1480px; margin:0 auto;
      flex-wrap:wrap;
    }
    .title{display:flex; flex-direction:column; gap:2px;}
    .title h1{font-size:16px; margin:0; font-weight:900; letter-spacing:.2px;}
    .title .sub{font-size:12px; color:var(--muted); line-height:1.25;}

    .pill{
      display:inline-flex; gap:10px; align-items:center;
      padding:8px 10px;
      background: rgba(17,24,36,.75);
      border:1px solid rgba(34,48,68,.9);
      border-radius:999px;
      box-shadow: var(--shadow);
      font-size:12px;
      color:var(--muted);
      white-space:nowrap;
    }
    .pill b{color:var(--text); font-weight:900}

    main{
      max-width:1480px; margin:0 auto; padding:14px;
      display:grid; grid-template-columns: 360px 1fr 360px;
      gap:14px;
    }
    body.simple main{ grid-template-columns: 1fr; }
    body.simple .leftSticky, body.simple .rightSticky{ display:none; }

    .card{
      background: linear-gradient(180deg, rgba(17,24,36,.92), rgba(15,22,32,.84));
      border:1px solid rgba(34,48,68,.9);
      border-radius:var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .card h2{
      margin:0;
      padding:10px 12px;
      font-size:13px;
      letter-spacing:.2px;
      border-bottom:1px solid rgba(34,48,68,.7);
      color:#dce8f7;
      display:flex; align-items:center; justify-content:space-between; gap:10px;
    }
    .card h2 small{color:var(--muted); font-weight:800; font-size:11px;}
    .card .content{padding:10px;}

    .grid{display:grid; gap:10px;}
    .grid.cols2{grid-template-columns:1fr 1fr;}
    .grid.cols3{grid-template-columns:1fr 1fr 1fr;}

    label{display:flex; flex-direction:column; gap:6px; font-size:11px; color:var(--muted);}

    input, select, button{font-family:inherit;}
    input, select{
      width:100%;
      padding:9px 10px;
      border-radius:10px;
      border:1px solid rgba(34,48,68,.9);
      background: rgba(11,15,20,.55);
      color: var(--text);
      outline:none;
    }
    input:focus, select:focus{
      border-color: rgba(100,181,255,.55);
      box-shadow: 0 0 0 3px rgba(100,181,255,.12);
    }

    .btn{
      border:none;
      border-radius:12px;
      padding:10px 12px;
      cursor:pointer;
      font-weight:900;
      letter-spacing:.2px;
      user-select:none;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      gap:8px;
      white-space:nowrap;
      background: rgba(159,176,195,.12);
      color:#e7eef7;
      border:1px solid rgba(159,176,195,.35);
      transition: transform .06s ease, filter .15s ease;
    }
    .btn:hover{filter: brightness(1.08);}
    .btn:active{transform: translateY(1px);}
    .btn.good{background: rgba(61,220,151,.16); color: #bdf8de; border:1px solid rgba(61,220,151,.45);}
    .btn.bad{background: rgba(255,91,110,.14); color: #ffd0d7; border:1px solid rgba(255,91,110,.45);}
    .btn.neutral{background: rgba(100,181,255,.14); color: #d4ebff; border:1px solid rgba(100,181,255,.45);}
    .btn.warn{background: rgba(255,207,91,.12); color: #ffe8b2; border:1px solid rgba(255,207,91,.35);}
    .btn.small{padding:8px 10px; border-radius:10px; font-size:12px;}

    .row{display:flex; gap:10px; align-items:center;}
    .row.wrap{flex-wrap:wrap;}

    .sep{height:1px; background: rgba(34,48,68,.7); margin: 12px 0;}
    .mono{font-family:var(--mono)}
    .muted{color:var(--muted)}
    .hint{font-size:12px; color: var(--muted); line-height:1.35;}

    .stat{
      display:flex; flex-direction:column; gap:2px;
      padding:9px 10px;
      border-radius:12px;
      border:1px solid rgba(34,48,68,.7);
      background: rgba(11,15,20,.35);
      min-width: 0;
    }
    .stat .k{font-size:11px; color:var(--muted);}
    .stat .v{font-family:var(--mono); font-size:13px; font-weight:900; color:var(--text); overflow:hidden; text-overflow:ellipsis; white-space:nowrap;}

    .chartTopBar{
      padding:10px 12px;
      border-bottom:1px solid rgba(34,48,68,.7);
      display:flex; align-items:center; justify-content:space-between;
      gap:10px; flex-wrap:wrap;
    }
    .chartTopBar .left{display:flex; gap:10px; align-items:center; flex-wrap:wrap;}
    .chartTopBar .right{display:flex; gap:10px; align-items:center; flex-wrap:wrap;}

    .miniField{
      display:flex; align-items:center; gap:8px;
      padding:8px 10px;
      border-radius:12px;
      border:1px solid rgba(34,48,68,.7);
      background: rgba(11,15,20,.35);
      color: var(--muted);
      font-size:12px;
      user-select:none;
      white-space:nowrap;
    }
    .miniField input{width:86px; padding:8px 8px; border-radius:10px; font-size:12px;}

    .toggle{
      display:flex; align-items:center; gap:8px;
      padding:8px 10px;
      border-radius:12px;
      border:1px solid rgba(34,48,68,.7);
      background: rgba(11,15,20,.35);
      color: var(--muted);
      font-size:12px;
      user-select:none;
      cursor:pointer;
      white-space:nowrap;
    }
    .toggle input{width:auto; transform: translateY(1px);}

    .speedGroup{
      display:flex; align-items:center; gap:6px;
      padding:6px;
      border-radius:12px;
      border:1px solid rgba(34,48,68,.7);
      background: rgba(11,15,20,.35);
    }
    .speedBtn{
      border:none; cursor:pointer;
      padding:7px 10px;
      border-radius:10px;
      font-weight:900; font-size:12px;
      background: rgba(159,176,195,.10);
      border:1px solid rgba(159,176,195,.25);
      color: rgba(231,238,247,.92);
    }
    .speedBtn.active{
      background: rgba(100,181,255,.16);
      border-color: rgba(100,181,255,.55);
      color: rgba(212,235,255,.98);
    }

    .chartWrap{height: 740px; padding: 10px 12px 12px;}
    canvas{
      width:100%;
      height:100%;
      display:block;
      border-radius:12px;
      border:1px solid rgba(34,48,68,.7);
      background: rgba(5,8,12,.65);
      touch-action: none;
      cursor: grab;
    }

    table{width:100%; border-collapse:collapse; font-size:12px;}
    thead th{
      text-align:left; color: var(--muted); font-size:11px; font-weight:900;
      padding:10px 8px; border-bottom:1px solid rgba(34,48,68,.7);
      position: sticky; top: 0;
      background: rgba(15,22,32,.96);
      backdrop-filter: blur(6px);
      z-index: 1;
    }
    tbody td{
      padding:9px 8px; border-bottom:1px solid rgba(34,48,68,.35);
      vertical-align:top; font-family: var(--mono);
    }
    tbody tr:hover{background: rgba(100,181,255,.06);}

    .tag{
      font-family: var(--mono);
      font-size:11px;
      padding:3px 6px;
      border-radius:999px;
      border:1px solid rgba(34,48,68,.8);
      background: rgba(11,15,20,.35);
      color: var(--muted);
    }
    .tag.buy{border-color: rgba(61,220,151,.45); color:#bdf8de; background: rgba(61,220,151,.10);}
    .tag.sell{border-color: rgba(255,91,110,.45); color:#ffd0d7; background: rgba(255,91,110,.10);}

    .log{
      height: 240px;
      overflow:auto;
      border-radius:12px;
      border:1px solid rgba(34,48,68,.7);
      background: rgba(11,15,20,.35);
      padding:10px;
      font-family: var(--mono);
      font-size:12px;
      line-height:1.35;
    }
    .log div{padding:3px 0; border-bottom:1px dashed rgba(34,48,68,.35);}
    .log div:last-child{border-bottom:none;}

    .rightSticky,.leftSticky{
      position:sticky; top:74px;
      height: calc(100vh - 88px);
      overflow:auto;
      padding-bottom: 16px;
    }

    .kbd{
      font-family: var(--mono);
      font-size: 11px;
      padding: 2px 6px;
      border-radius: 8px;
      border:1px solid rgba(34,48,68,.9);
      background: rgba(11,15,20,.55);
      color: rgba(231,238,247,.95);
    }

    .overlayHelp{
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,.55);
      backdrop-filter: blur(6px);
      display:none;
      z-index: 10;
      align-items:center;
      justify-content:center;
      padding: 18px;
    }
    .overlayHelp.open{display:flex;}
    .helpCard{
      max-width: 900px;
      width: 100%;
      border-radius: 16px;
      border:1px solid rgba(34,48,68,.95);
      background: linear-gradient(180deg, rgba(17,24,36,.96), rgba(11,15,20,.92));
      box-shadow: var(--shadow);
      padding: 14px;
    }
    .helpGrid{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
      margin-top: 10px;
    }
    .helpItem{
      border:1px solid rgba(34,48,68,.7);
      border-radius: 12px;
      background: rgba(11,15,20,.35);
      padding: 10px;
      font-size: 12px;
      color: var(--muted);
      line-height: 1.35;
    }
    .helpItem b{ color: var(--text); }

    @media (max-width: 1220px){
      main{grid-template-columns: 1fr;}
      .rightSticky,.leftSticky{position:static; height:auto;}
      .chartWrap{height:440px;}
      .miniField input{width:110px;}
      body.simple .leftSticky, body.simple .rightSticky{ display:none; }
    }
  </style>
</head>

<body class="simple">
<header>
  <div class="row">
    <div class="title">
      <h1>Market Sandbox ‚Äî TV-like Chart üìà (Improved)</h1>
      <div class="sub">
        Drag=pan X ‚Ä¢ <span class="kbd">Shift</span>+Drag=pan Y ‚Ä¢ Wheel=zoom X ‚Ä¢ <span class="kbd">Shift</span>+Wheel=zoom Y ‚Ä¢ Ctrl+Click=Limit ‚Ä¢ Alt+Click=Cancel ‚Ä¢ <span class="kbd">?</span>=help
      </div>
    </div>
    <div class="row wrap">
      <div class="pill">–ò–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç: <b id="sym">NQ (sim)</b></div>
      <div class="pill">–¶–µ–Ω–∞: <b id="hdrPrice">‚Äî</b></div>
      <div class="pill">–ü–æ–∑–∏—Ü–∏—è: <b id="hdrPos">0</b></div>
      <div class="pill">uPnL: <b id="hdrPnL">‚Äî</b></div>
      <div class="pill">Speed: <b id="hdrSpeed">1.0x</b></div>
      <div class="pill">Y-zoom: <b id="hdrY">1.00x</b></div>
    </div>
  </div>
</header>

<main>
  <!-- LEFT (advanced panel) -->
  <div class="leftSticky">
    <section class="card">
      <h2>–û—Ä–¥–µ—Ä–∞ <small>mkt + limit</small></h2>
      <div class="content grid">
        <div class="grid cols2">
          <label>–ö–æ–ª-–≤–æ (qty)<input id="qty" type="number" step="1" min="1" value="1" /></label>
          <label>–ü—Ä–æ—Å–∫–∞–ª—å–∑—ã–≤–∞–Ω–∏–µ (ticks)<input id="slip" type="number" step="1" min="0" value="1" /></label>
        </div>

        <div class="sep"></div>

        <div class="grid cols2">
          <label>–¢–∏–ø –ª–∏–º–∏—Ç–∫–∏
            <select id="limitSide">
              <option value="buy">Limit Buy</option>
              <option value="sell">Limit Sell</option>
            </select>
          </label>
          <label>–¶–µ–Ω–∞ –ª–∏–º–∏—Ç–∫–∏<input id="limitPrice" type="number" step="0.25" value="0" /></label>
        </div>
        <button class="btn neutral" id="placeLimit">‚ûï –ü–æ—Å—Ç–∞–≤–∏—Ç—å Limit</button>

        <div class="sep"></div>

        <div class="grid cols2">
          <button class="btn" id="cancelAll">üßπ Cancel All</button>
          <button class="btn" id="flatten">üßØ Flatten (mkt)</button>
        </div>

        <div class="hint">
          –ë—ã—Å—Ç—Ä–æ: <span class="kbd">Ctrl+–õ–ö–ú</span> –ø–æ –≥—Ä–∞—Ñ–∏–∫—É = Buy Limit, <span class="kbd">Ctrl+–ü–ö–ú</span> = Sell Limit.
          <span class="kbd">Alt+–∫–ª–∏–∫</span> = –æ—Ç–º–µ–Ω–∏—Ç—å –±–ª–∏–∂–∞–π—à—É—é –ª–∏–º–∏—Ç–∫—É.
        </div>
      </div>
    </section>

    <section class="card" style="margin-top:14px">
      <h2>–î–≤–∏–∂–æ–∫ —Ä—ã–Ω–∫–∞ <small>sandbox params</small></h2>
      <div class="content grid">
        <div class="grid cols2">
          <label>Volatility (1‚Äì20)<input id="vol" type="number" step="1" min="1" max="20" value="8" /></label>
          <label>Liquidity (1‚Äì20)<input id="liq" type="number" step="1" min="1" max="20" value="10" /></label>
        </div>
        <div class="grid cols2">
          <label>Impact (0‚Äì20)<input id="impact" type="number" step="1" min="0" max="20" value="8" /></label>
          <label>Base ticks/sec (5‚Äì120)<input id="simHzBase" type="number" step="1" min="5" max="120" value="60" /></label>
        </div>
        <div class="grid cols2">
          <label>Tick size<input id="tick" type="number" step="0.01" min="0.01" value="0.25" /></label>
          <label>Spread (ticks)<input id="spread" type="number" step="1" min="0" value="1" /></label>
        </div>

        <div class="grid cols2">
          <label>–¢–∞–π–º—Ñ—Ä–µ–π–º (—Å–∏–º)
            <select id="timeframe">
              <option value="1s">1s</option>
              <option value="5s" selected>5s</option>
              <option value="15s">15s</option>
              <option value="1m">1m</option>
              <option value="5m">5m</option>
              <option value="15m">15m</option>
            </select>
          </label>
          <label>–°–≤–µ—á–µ–π –Ω–∞ —ç–∫—Ä–∞–Ω–µ<input id="visibleBars" type="number" step="5" min="20" max="700" value="160" /></label>
        </div>

        <div class="grid cols2">
          <button class="btn neutral" id="pause">‚è∏Ô∏è Pause</button>
          <button class="btn neutral" id="reset">üîÅ Reset</button>
        </div>
      </div>
    </section>
  </div>

  <!-- CENTER -->
  <section class="card">
    <h2>–ì—Ä–∞—Ñ–∏–∫ <small>Sandbox mode</small></h2>

    <div class="chartTopBar">
      <div class="left">
        <button class="btn good" id="buyMktTop" title="Hotkey: B">‚¨ÜÔ∏è Buy MKT</button>
        <button class="btn bad" id="sellMktTop" title="Hotkey: S">‚¨áÔ∏è Sell MKT</button>

        <div class="miniField">qty <input id="qtyTop" type="number" step="1" min="1" value="1" /></div>
        <div class="miniField">slip <input id="slipTop" type="number" step="1" min="0" value="1" /></div>

        <div class="toggle" id="followWrap" title="Hotkey: F">
          <input id="follow" type="checkbox" checked />
          <span>Follow</span>
        </div>

        <div class="speedGroup" title="Speed presets">
          <button class="speedBtn" data-speed="0.5">0.5x</button>
          <button class="speedBtn active" data-speed="1">1x</button>
          <button class="speedBtn" data-speed="2">2x</button>
          <button class="speedBtn" data-speed="5">5x</button>
          <button class="speedBtn" data-speed="10">10x</button>
        </div>

        <button class="btn small neutral" id="stepTick" title="Step 1 tick (works when paused)">‚è≠ Step</button>
        <button class="btn small" id="resetView" title="Reset view (X/Y)">üß≠ Reset view</button>

        <button class="btn small neutral" id="toggleMode" title="Toggle Simple/Advanced">üß© Advanced</button>
        <button class="btn small" id="openHelp" title="Hotkey: ?">‚ùî Help</button>
      </div>

      <div class="right">
        <div class="miniField mono">
          Wheel=zoom X ‚Ä¢ Shift+Wheel=zoom Y ‚Ä¢ Drag=pan X ‚Ä¢ Shift+Drag=pan Y ‚Ä¢ Ctrl+Click=Limit ‚Ä¢ Alt+Click=Cancel
        </div>
      </div>
    </div>

    <div class="chartWrap">
      <canvas id="chart"></canvas>
    </div>

    <div class="content">
      <div class="row wrap">
        <div class="stat"><div class="k">Last</div><div class="v" id="stLast">‚Äî</div></div>
        <div class="stat"><div class="k">Bid / Ask</div><div class="v" id="stBA">‚Äî</div></div>
        <div class="stat"><div class="k">Net Pos</div><div class="v" id="stPos">0</div></div>
        <div class="stat"><div class="k">Avg</div><div class="v" id="stAvg">‚Äî</div></div>
        <div class="stat"><div class="k">uPnL</div><div class="v" id="stPnL">‚Äî</div></div>
        <div class="stat"><div class="k">Window</div><div class="v" id="stWin">‚Äî</div></div>
      </div>
      <div class="hint" style="margin-top:10px">
        –≠—Ç–æ sandbox: —Ç—Ä–µ–Ω–∞–∂—ë—Ä —Ä–µ–∞–∫—Ü–∏–∏/–æ—Ä–¥–µ—Ä–æ–≤/–Ω–∞–≤–∏–≥–∞—Ü–∏–∏. –ù–µ –±—ç–∫—Ç–µ—Å—Ç.
      </div>
    </div>
  </section>

  <!-- RIGHT (advanced panel) -->
  <div class="rightSticky">
    <section class="card">
      <h2>–ê–∫—Ç–∏–≤–Ω—ã–µ –ª–∏–º–∏—Ç–∫–∏ <small>click ‚Üí cancel</small></h2>
      <div class="content" style="padding:0">
        <div style="max-height:320px; overflow:auto">
          <table>
            <thead>
              <tr>
                <th style="width:70px">Side</th>
                <th>Price</th>
                <th>Qty</th>
                <th>Left</th>
                <th style="width:90px">ID</th>
              </tr>
            </thead>
            <tbody id="ordersBody"></tbody>
          </table>
        </div>
      </div>
    </section>

    <section class="card" style="margin-top:14px">
      <h2>–õ–æ–≥ <small>fills/cancel</small></h2>
      <div class="content">
        <div class="log" id="log"></div>
        <div class="row wrap" style="margin-top:10px">
          <button class="btn small" id="clearLog">üßΩ Clear log</button>
        </div>
      </div>
    </section>
  </div>
</main>

<!-- Help overlay -->
<div class="overlayHelp" id="helpOverlay">
  <div class="helpCard">
    <div class="row" style="justify-content:space-between; align-items:center;">
      <div style="font-weight:900;">Hotkeys / Controls</div>
      <button class="btn small" id="closeHelp">‚úñ Close</button>
    </div>
    <div class="helpGrid">
      <div class="helpItem"><b>B</b> = Buy Market ‚Ä¢ <b>S</b> = Sell Market</div>
      <div class="helpItem"><b>Space</b> = Pause/Resume ‚Ä¢ <b>Step</b> = 1 tick on pause</div>
      <div class="helpItem"><b>F</b> = Follow on/off</div>
      <div class="helpItem"><b>C</b> = Cancel All ‚Ä¢ <b>X</b> = Flatten</div>
      <div class="helpItem"><b>Wheel</b> = zoom X (bars) ‚Ä¢ <b>Shift+Wheel</b> = zoom Y</div>
      <div class="helpItem"><b>Drag</b> = pan X ‚Ä¢ <b>Shift+Drag</b> = pan Y</div>
      <div class="helpItem"><b>Ctrl+Click</b> chart = Place Limit (LMB=BUY, RMB=SELL)</div>
      <div class="helpItem"><b>Alt+Click</b> chart = Cancel nearest limit by price</div>
      <div class="helpItem"><b>R</b> = Reset View (X/Y)</div>
      <div class="helpItem"><b>?</b> = open/close help</div>
    </div>
    <div class="hint" style="margin-top:10px">
      TradingView-—Å—Ç–∏–ª—å –ø—É—Å—Ç–æ—Ç—ã: –º–æ–∂–Ω–æ —É–µ–∑–∂–∞—Ç—å –∏ –≤ –ø—Ä–æ—à–ª–æ–µ, –∏ –≤ –±—É–¥—É—â–µ–µ. Follow –¥–µ—Ä–∂–∏—Ç –≥—Ä–∞—Ñ–∏–∫ —É –ø—Ä–∞–≤–æ–≥–æ –∫—Ä–∞—è, –Ω–æ –ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç space —Å–ø—Ä–∞–≤–∞.
    </div>
  </div>
</div>

<script>
(() => {
  const $ = (id) => document.getElementById(id);
  const now = () => new Date().toLocaleTimeString();
  const clamp = (x, a, b) => Math.max(a, Math.min(b, x));
  const roundTo = (x, step) => Math.round(x / step) * step;

  const state = {
    symbol: "NQ (sim)",
    tickSize: 0.25,
    spreadTicks: 1,
    volatility: 8,
    liquidity: 10,
    impact: 8,

    baseSimHz: 60,
    speedMul: 1,
    simHz: 60,

    paused: false,

    price: 17000,
    velocity: 0,

    pos: 0,
    avg: null,

    bars: [],
    lastBarIdx: 0,
    barTicks: 300,
    _barCounter: 0,
    _curBar: null,

    nextOrderId: 1,
    limits: [],

    visibleBars: 160,

    // TV-like space:
    futureBars: 140,   // how far you can go into "future" (blank)
    pastBars: 350,     // how far you can go into "past" beyond first bar
    followPad: 22,     // blank space shown on the right while following (TV-like)
    rightOffset: 0,    // 0 = last bar at right edge; negative = show future blank; positive = go into past
    follow: true,

    // Y view
    yScale: 1.0,  // >1 zoom in (less range), <1 zoom out
    yOffset: 0.0, // shifts mid price up/down

    pointers: new Map(),
    panStart: null,
    pinchStart: null,

    geo: null,

    cross: { on:false, x:0, y:0, idx:null, price:null },
  };

  $("sym").textContent = state.symbol;

  let ordersDirty = true;
  let statsDirty  = true;
  let cachedFontBody = null;

  function log(msg, kind="") {
    const el = $("log");
    const line = document.createElement("div");
    line.innerHTML = `<span class="muted">[${now()}]</span> ${msg}`;
    if (kind === "good") line.style.color = "#bdf8de";
    if (kind === "bad")  line.style.color = "#ffd0d7";
    if (kind === "warn") line.style.color = "#ffe8b2";
    el.prepend(line);
  }

  function getBidAsk() {
    const spread = state.spreadTicks * state.tickSize;
    const mid = state.price;
    return { bid: mid - spread/2, ask: mid + spread/2 };
  }

  function computeUPnL() {
    if (!state.pos || state.avg == null) return null;
    return (state.price - state.avg) * state.pos;
  }

  function applyFill(side, qty, fillPrice, reason="") {
    const oldPos = state.pos;
    const newPos = oldPos + (side === "buy" ? qty : -qty);

    if (oldPos === 0) state.avg = fillPrice;
    else if (Math.sign(oldPos) === Math.sign(newPos) && newPos !== 0) {
      const oldAbs = Math.abs(oldPos);
      const newAbs = Math.abs(newPos);
      const addQty = newAbs - oldAbs;
      if (addQty > 0) state.avg = (state.avg * oldAbs + fillPrice * addQty) / newAbs;
    } else if (newPos === 0) state.avg = null;
    else if (Math.sign(oldPos) !== Math.sign(newPos)) state.avg = fillPrice;

    state.pos = newPos;
    statsDirty = true;

    const tag = side === "buy" ? "üü¢" : "üî¥";
    log(`${tag} FILLED <span class="mono">${side.toUpperCase()}</span> qty=<span class="mono">${qty}</span> @ <span class="mono">${fillPrice.toFixed(2)}</span> <span class="muted">(${reason})</span>`,
      side === "buy" ? "good" : "bad"
    );
  }

  function marketOrder(side, qty, slipTicks) {
    const { bid, ask } = getBidAsk();
    const slip = slipTicks * state.tickSize;
    const fill = side === "buy" ? (ask + slip) : (bid - slip);
    applyFill(side, qty, fill, "market");
  }

  function placeLimit(side, price, qty) {
    price = roundTo(price, state.tickSize);
    const id = state.nextOrderId++;
    state.limits.push({ id, side, price, qty, left: qty, createdAt: Date.now() });
    ordersDirty = true;
    log(`‚ûï LIMIT <span class="mono">${side.toUpperCase()}</span> qty=<span class="mono">${qty}</span> @ <span class="mono">${price.toFixed(2)}</span> <span class="muted">(id=${id})</span>`, "warn");
  }

  function cancelOrder(id) {
    const idx = state.limits.findIndex(o => o.id === id);
    if (idx >= 0) {
      const o = state.limits[idx];
      state.limits.splice(idx, 1);
      ordersDirty = true;
      log(`‚úñ CANCEL id=<span class="mono">${id}</span> (${o.side} @ ${o.price.toFixed(2)}, left=${o.left})`, "warn");
    }
  }

  function cancelAll() {
    const n = state.limits.length;
    state.limits = [];
    ordersDirty = true;
    log(`üßπ Cancel All (${n} orders)`, "warn");
  }

  function flatten() {
    if (state.pos === 0) { log("üßØ Flatten: –ø–æ–∑–∏—Ü–∏—è —É–∂–µ 0", "warn"); return; }
    const qty = Math.abs(state.pos);
    const side = state.pos > 0 ? "sell" : "buy";
    marketOrder(side, qty, getSlip());
    log("üßØ Flatten done", "warn");
    statsDirty = true;
  }

  function cancelNearestLimitByPrice(price) {
    if (!state.limits.length) return false;
    let best = null;
    for (const o of state.limits) {
      const d = Math.abs(o.price - price);
      if (!best || d < best.d) best = { d, id: o.id };
    }
    const maxDelta = state.tickSize * 6;
    if (best && best.d <= maxDelta) {
      cancelOrder(best.id);
      return true;
    }
    return false;
  }

  function matchLimits() {
    const { bid, ask } = getBidAsk();
    const liq = clamp(state.liquidity, 1, 20);

    const filledIds = [];
    for (const o of state.limits) {
      if (o.left <= 0) { filledIds.push(o.id); continue; }
      const canFill = (o.side === "buy") ? (ask <= o.price) : (bid >= o.price);
      if (!canFill) continue;

      const baseChunk = Math.max(1, Math.round(o.qty * (21 - liq) / 20));
      const chunk = Math.min(o.left, baseChunk);

      o.left -= chunk;
      applyFill(o.side, chunk, o.price, `limit id=${o.id}`);
      ordersDirty = true;

      if (o.left <= 0) filledIds.push(o.id);
    }
    if (filledIds.length) {
      state.limits = state.limits.filter(o => !filledIds.includes(o.id));
      ordersDirty = true;
    }
  }

  function timeframeToBarTicks(tf, simHz) {
    if (tf === "1s") return Math.max(2, Math.round(1 * simHz));
    if (tf === "5s") return Math.max(2, Math.round(5 * simHz));
    if (tf === "15s") return Math.max(2, Math.round(15 * simHz));
    if (tf === "1m") return Math.max(2, Math.round(60 * simHz));
    if (tf === "5m") return Math.max(2, Math.round(300 * simHz));
    if (tf === "15m") return Math.max(2, Math.round(900 * simHz));
    return Math.max(2, Math.round(5 * simHz));
  }

  function ensureCurrentBar() {
    if (!state._curBar) {
      state._curBar = { idx: state.lastBarIdx + 1, o: state.price, h: state.price, l: state.price, c: state.price };
      state._barCounter = 0;
    }
  }

  function updateBarsWithPrice(p) {
    ensureCurrentBar();
    state._curBar.h = Math.max(state._curBar.h, p);
    state._curBar.l = Math.min(state._curBar.l, p);
    state._curBar.c = p;

    state._barCounter++;
    if (state._barCounter >= state.barTicks) {
      state.lastBarIdx = state._curBar.idx;
      state.bars.push(state._curBar);
      if (state.bars.length > 8000) state.bars.shift();

      state._curBar = { idx: state.lastBarIdx + 1, o: p, h: p, l: p, c: p };
      state._barCounter = 0;

      if (state.follow) state.rightOffset = -state.followPad;
    }
  }

  function stepSimulationOnce() {
    const vol = clamp(state.volatility, 1, 20);
    const r = (Math.random()+Math.random()+Math.random()+Math.random()-2);
    const noise = r * (vol * state.tickSize * 0.18);

    const imp = clamp(state.impact, 0, 20);
    const liq = clamp(state.liquidity, 1, 20);

    // slight "pressure" from position just to feel reactive (sandbox), not realistic
    const posPressure = (state.pos) * (imp * state.tickSize * 0.004) * (1 / (liq * 0.55));

    state.velocity = (state.velocity * 0.92) + noise + posPressure;
    state.price = roundTo(state.price + state.velocity, state.tickSize);

    statsDirty = true;

    updateBarsWithPrice(state.price);
    matchLimits();
  }

  function getAllBarsForRender() {
    const arr = state.bars.slice();
    if (state._curBar) arr.push(state._curBar);
    return arr;
  }

  // TV-like window using idx space (can be outside real data)
  function getWindowBars() {
    const all = getAllBarsForRender();
    const n = all.length;
    if (n === 0) return { all:[], vis:0, startIdx:0, endIdx:0, firstIdx:0, lastIdx:0 };

    const vis = clamp(state.visibleBars, 20, 700);
    const firstIdx = all[0].idx;
    const lastIdx  = all[n - 1].idx;

    const endIdx   = lastIdx - state.rightOffset;     // > lastIdx allowed (future blank)
    const startIdx = endIdx - (vis - 1);

    return { all, vis, startIdx, endIdx, firstIdx, lastIdx };
  }

  function clampOffset() {
    const all = getAllBarsForRender();
    if (all.length < 2) { state.rightOffset = -state.followPad; return; }

    const first = all[0].idx;
    const last  = all[all.length - 1].idx;

    const maxPast   = (last - first) + state.pastBars;
    const maxFuture = state.futureBars;

    state.rightOffset = clamp(state.rightOffset, -maxFuture, maxPast);
  }

  function computeBaseRange(barsInView) {
    let min = Infinity, max = -Infinity;

    for (const b of barsInView) { min = Math.min(min, b.l); max = Math.max(max, b.h); }
    for (const o of state.limits) { min = Math.min(min, o.price); max = Math.max(max, o.price); }

    if (!Number.isFinite(min) || !Number.isFinite(max) || min === max) {
      min = state.price - 50 * state.tickSize;
      max = state.price + 50 * state.tickSize;
    }
    const pad = (max-min) * 0.12 + state.tickSize * 20;
    return { min: min - pad, max: max + pad };
  }

  function computePriceRange(barsInView) {
    const base = computeBaseRange(barsInView);
    const baseMid = (base.min + base.max) / 2;
    const baseRange = Math.max(state.tickSize * 20, (base.max - base.min));

    const yScale = clamp(state.yScale, 0.25, 8);
    const mid = baseMid + state.yOffset;
    const range = baseRange / yScale;

    return { min: mid - range/2, max: mid + range/2 };
  }

  function niceStep(range, targetTicks=8) {
    const raw = range / targetTicks;
    const pow = Math.pow(10, Math.floor(Math.log10(raw)));
    const frac = raw / pow;
    let niceFrac;
    if (frac <= 1) niceFrac = 1;
    else if (frac <= 2) niceFrac = 2;
    else if (frac <= 5) niceFrac = 5;
    else niceFrac = 10;
    return niceFrac * pow;
  }

  // ===== HiDPI canvas
  const canvas = $("chart");
  const ctx = canvas.getContext("2d", { alpha: true });

  function resizeCanvasToDisplaySize() {
    const rect = canvas.getBoundingClientRect();
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    const displayW = Math.round(rect.width * dpr);
    const displayH = Math.round(rect.height * dpr);
    if (canvas.width !== displayW || canvas.height !== displayH) {
      canvas.width = displayW;
      canvas.height = displayH;
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }
  }
  window.addEventListener("resize", resizeCanvasToDisplaySize);

  function buildGeo(slotCount, pr, startIdx) {
    const rect = canvas.getBoundingClientRect();
    const w = rect.width, h = rect.height;

    const leftPad = 74;
    const rightPad = 14;
    const topPad = 10;
    const bottomPad = 26;

    const plotX0 = leftPad;
    const plotX1 = w - rightPad;
    const plotY0 = topPad;
    const plotY1 = h - bottomPad;

    const n = Math.max(2, slotCount);

    const candleW = Math.max(3, Math.floor((plotX1 - plotX0) / (n + 10)));
    const gap = Math.max(1, Math.floor(candleW * 0.35));
    const step = candleW + gap;

    const totalW = step * n;
    const xStart = plotX0 + Math.max(6, Math.floor(((plotX1 - plotX0) - totalW) / 2));

    const yOf = (p) => {
      const yy = plotY1 - ((p - pr.min) / (pr.max - pr.min)) * (plotY1 - plotY0);
      return clamp(yy, plotY0, plotY1);
    };

    const xOf = (vIdx) => xStart + (vIdx - startIdx) * step;
    const xCenterOf = (vIdx) => xOf(vIdx) + candleW / 2;

    return {
      w,h,leftPad,rightPad,topPad,bottomPad,
      plotX0,plotX1,plotY0,plotY1,
      candleW,gap,step,totalW,xStart,
      startIdx, slotCount: n,
      yOf, xOf, xCenterOf,
      stepPxScreen: step
    };
  }

  function canvasPointFromClient(e) {
    const r = canvas.getBoundingClientRect();
    return { x: (e.clientX - r.left), y: (e.clientY - r.top) };
  }

  function priceFromY(y, pr, geo) {
    const t = (geo.plotY1 - y) / (geo.plotY1 - geo.plotY0);
    const p = pr.min + t * (pr.max - pr.min);
    return roundTo(p, state.tickSize);
  }

  function idxFromX(x, geo) {
    const slot = Math.round((x - geo.xStart) / geo.step);
    return Math.round(geo.startIdx + slot);
  }

  function stepPxScreen() {
    return state.geo ? Math.max(2, state.geo.stepPxScreen) : 8;
  }

  // ===== draw
  function drawChart() {
    resizeCanvasToDisplaySize();

    const rect = canvas.getBoundingClientRect();
    const w = rect.width, h = rect.height;
    ctx.clearRect(0,0,w,h);

    const win = getWindowBars();
    if (!win.vis) return;

    const { all, startIdx, endIdx, vis } = win;

    const lo = Math.ceil(startIdx);
    const hi = Math.floor(endIdx);
    const barsInView = all.filter(b => b.idx >= lo && b.idx <= hi);

    const pr = computePriceRange(barsInView.length ? barsInView : all.slice(-80));
    const geo = buildGeo(vis, pr, startIdx);
    state.geo = geo;

    if (!cachedFontBody) cachedFontBody = "12px " + getComputedStyle(document.body).fontFamily;
    ctx.font = cachedFontBody;
    ctx.textBaseline = "middle";

    // plot bg
    ctx.fillStyle = "rgba(5,8,12,0.35)";
    ctx.fillRect(geo.plotX0, geo.plotY0, geo.plotX1-geo.plotX0, geo.plotY1-geo.plotY0);

    // left scale bg
    ctx.fillStyle = "rgba(11,15,20,0.55)";
    ctx.fillRect(0, 0, geo.leftPad, h);

    // divider
    ctx.strokeStyle = "rgba(34,48,68,0.9)";
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(geo.leftPad + 0.5, 0);
    ctx.lineTo(geo.leftPad + 0.5, h);
    ctx.stroke();

    // grid + price labels
    let step = niceStep(pr.max - pr.min, 8);
    step = Math.max(state.tickSize, roundTo(step, state.tickSize));
    const startP = Math.floor(pr.min / step) * step;

    for (let p = startP; p <= pr.max + step; p += step) {
      const price = roundTo(p, state.tickSize);
      const y = geo.yOf(price);

      ctx.strokeStyle = "rgba(34,48,68,0.45)";
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(geo.plotX0, y);
      ctx.lineTo(geo.plotX1, y);
      ctx.stroke();

      ctx.fillStyle = "rgba(159,176,195,0.95)";
      ctx.fillText(price.toFixed(2), 8, y);
    }

    // vertical guides by slots
    ctx.strokeStyle = "rgba(34,48,68,0.35)";
    const stepGuides = Math.max(5, Math.round(vis / 10));
    for (let s = 0; s < vis; s += stepGuides) {
      const vIdx = geo.startIdx + s;
      const x = geo.xCenterOf(vIdx);
      ctx.beginPath(); ctx.moveTo(x, geo.plotY0); ctx.lineTo(x, geo.plotY1); ctx.stroke();
    }

    // bid/ask band
    const {bid, ask} = getBidAsk();
    const yBid = geo.yOf(bid), yAsk = geo.yOf(ask);
    ctx.fillStyle = "rgba(159,176,195,0.08)";
    ctx.fillRect(geo.plotX0, Math.min(yBid,yAsk), geo.plotX1-geo.plotX0, Math.abs(yBid-yAsk));

    // candles (only where real bars exist)
    for (const b of barsInView) {
      const x = geo.xOf(b.idx);
      const yO = geo.yOf(b.o), yH = geo.yOf(b.h), yL = geo.yOf(b.l), yC = geo.yOf(b.c);
      const up = b.c >= b.o;

      ctx.strokeStyle = up ? "rgba(61,220,151,0.85)" : "rgba(255,91,110,0.85)";
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.moveTo(x + geo.candleW/2, yH);
      ctx.lineTo(x + geo.candleW/2, yL);
      ctx.stroke();

      const bodyTop = Math.min(yO, yC);
      const bodyH = Math.max(2, Math.abs(yC - yO));
      ctx.fillStyle = up ? "rgba(61,220,151,0.30)" : "rgba(255,91,110,0.28)";
      ctx.strokeStyle = up ? "rgba(61,220,151,0.95)" : "rgba(255,91,110,0.95)";
      ctx.lineWidth = 1.5;
      ctx.fillRect(x, bodyTop, geo.candleW, bodyH);
      ctx.strokeRect(x, bodyTop, geo.candleW, bodyH);
    }

    // limits
    for (const o of state.limits) {
      const y = geo.yOf(o.price);

      ctx.strokeStyle = o.side === "buy" ? "rgba(61,220,151,0.65)" : "rgba(255,91,110,0.65)";
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.moveTo(geo.plotX0, y);
      ctx.lineTo(geo.plotX1, y);
      ctx.stroke();

      ctx.fillStyle = o.side === "buy" ? "rgba(61,220,151,0.9)" : "rgba(255,91,110,0.9)";
      ctx.fillText(`${o.side.toUpperCase()} ${o.price.toFixed(2)} (left ${o.left})`, geo.plotX0 + 10, y - 10);
    }

    // last price label
    const yLast = geo.yOf(state.price);
    ctx.fillStyle = "rgba(100,181,255,0.20)";
    ctx.fillRect(0, yLast - 12, geo.leftPad, 24);
    ctx.strokeStyle = "rgba(100,181,255,0.70)";
    ctx.lineWidth = 1.2;
    ctx.strokeRect(0.5, yLast - 11.5, geo.leftPad-1, 23);
    ctx.fillStyle = "rgba(211,236,255,0.98)";
    ctx.fillText(state.price.toFixed(2), 8, yLast);

    // crosshair
    if (state.cross.on && state.cross.idx != null && state.cross.price != null) {
      const x = clamp(state.cross.x, geo.plotX0, geo.plotX1);
      const y = clamp(state.cross.y, geo.plotY0, geo.plotY1);

      ctx.strokeStyle = "rgba(159,176,195,0.55)";
      ctx.lineWidth = 1;
      ctx.setLineDash([4,4]);
      ctx.beginPath(); ctx.moveTo(geo.plotX0, y); ctx.lineTo(geo.plotX1, y); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(x, geo.plotY0); ctx.lineTo(x, geo.plotY1); ctx.stroke();
      ctx.setLineDash([]);

      // price label
      ctx.fillStyle = "rgba(159,176,195,0.14)";
      ctx.fillRect(0, y - 12, geo.leftPad, 24);
      ctx.strokeStyle = "rgba(159,176,195,0.55)";
      ctx.strokeRect(0.5, y - 11.5, geo.leftPad-1, 23);
      ctx.fillStyle = "rgba(231,238,247,0.98)";
      ctx.fillText(state.cross.price.toFixed(2), 8, y);

      // idx label bottom
      const lab = String(state.cross.idx);
      const bw = ctx.measureText(lab).width + 14;
      const bx = clamp(x - bw/2, geo.plotX0, geo.plotX1 - bw);
      const by = geo.plotY1 + 2;
      ctx.fillStyle = "rgba(11,15,20,0.75)";
      ctx.fillRect(bx, by, bw, 20);
      ctx.strokeStyle = "rgba(34,48,68,0.9)";
      ctx.strokeRect(bx+0.5, by+0.5, bw-1, 19);
      ctx.fillStyle = "rgba(231,238,247,0.95)";
      ctx.fillText(lab, bx + 7, by + 10);
    }

    $("stWin").textContent = `${Math.round(startIdx)} ‚Üí ${Math.round(endIdx)} (offset ${state.rightOffset})`;
  }

  // ===== UI
  function renderOrdersTable() {
    const body = $("ordersBody");
    body.innerHTML = "";
    const orders = [...state.limits].sort((a,b) => a.price - b.price);
    for (const o of orders) {
      const tr = document.createElement("tr");
      tr.style.cursor = "pointer";
      tr.title = "–ù–∞–∂–º–∏ —á—Ç–æ–±—ã –æ—Ç–º–µ–Ω–∏—Ç—å";
      tr.addEventListener("click", () => cancelOrder(o.id));
      const sideTag = o.side === "buy"
        ? `<span class="tag buy">BUY</span>`
        : `<span class="tag sell">SELL</span>`;
      tr.innerHTML = `
        <td>${sideTag}</td>
        <td>${o.price.toFixed(2)}</td>
        <td>${o.qty}</td>
        <td>${o.left}</td>
        <td>${o.id}</td>
      `;
      body.appendChild(tr);
    }
  }

  function renderStats() {
    const { bid, ask } = getBidAsk();
    const upnl = computeUPnL();

    $("hdrPrice").textContent = state.price.toFixed(2);
    $("hdrPos").textContent = String(state.pos);
    $("hdrPnL").textContent = upnl == null ? "‚Äî" : upnl.toFixed(2);
    $("hdrSpeed").textContent = state.speedMul.toFixed(1) + "x";
    $("hdrY").textContent = state.yScale.toFixed(2) + "x";

    $("stLast").textContent = state.price.toFixed(2);
    $("stBA").textContent = `${bid.toFixed(2)} / ${ask.toFixed(2)}`;
    $("stPos").textContent = String(state.pos);
    $("stAvg").textContent = state.avg == null ? "‚Äî" : state.avg.toFixed(2);
    $("stPnL").textContent = upnl == null ? "‚Äî" : upnl.toFixed(2);
  }

  function syncTopFromLeft() {
    if (document.activeElement !== $("qtyTop")) $("qtyTop").value = $("qty").value;
    if (document.activeElement !== $("slipTop")) $("slipTop").value = $("slip").value;
  }
  function syncLeftFromTop() {
    $("qty").value = String(Math.max(1, Math.floor(Number($("qtyTop").value || 1))));
    $("slip").value = String(Math.max(0, Math.floor(Number($("slipTop").value || 0))));
  }

  function getQty() {
    const q = Number($("qtyTop").value || $("qty").value || 1);
    return Math.max(1, Math.floor(q));
  }
  function setQty(v) {
    const x = Math.max(1, Math.floor(v));
    $("qtyTop").value = String(x);
    $("qty").value = String(x);
  }
  function getSlip() {
    const s = Number($("slipTop").value || $("slip").value || 0);
    return Math.max(0, Math.floor(s));
  }

  function applySettingsFromUI() {
    state.tickSize = Number($("tick").value) || 0.25;
    state.spreadTicks = Math.max(0, Number($("spread").value || 0));
    state.volatility = clamp(Number($("vol").value || 8), 1, 20);
    state.liquidity  = clamp(Number($("liq").value || 10), 1, 20);
    state.impact     = clamp(Number($("impact").value || 8), 0, 20);

    state.baseSimHz  = clamp(Number($("simHzBase").value || 60), 5, 120);
    state.simHz      = clamp(state.baseSimHz * state.speedMul, 5, 600);

    state.visibleBars = clamp(Number($("visibleBars").value || 160), 20, 700);
    state.barTicks = timeframeToBarTicks($("timeframe").value, state.simHz);

    state.follow = $("follow").checked;

    syncTopFromLeft();
  }

  // ===== Zoom X (wheel) + Zoom Y (shift+wheel)
  canvas.addEventListener("wheel", (e) => {
    e.preventDefault();
    applySettingsFromUI();

    const winBefore = getWindowBars();
    if (!winBefore.vis) return;

    const rect = canvas.getBoundingClientRect();
    const xCss = (e.clientX - rect.left);
    const xFrac = clamp(xCss / rect.width, 0, 1);

    const dir = (e.deltaY > 0) ? +1 : -1;

    // Y-zoom
    if (e.shiftKey) {
      const mul = (dir < 0) ? 1.12 : 0.89;      // wheel up = zoom in
      state.yScale = clamp(state.yScale * mul, 0.25, 8);
      statsDirty = true;
      return;
    }

    // X-zoom
    const factor = (dir < 0) ? 0.86 : 1.18;     // wheel up = zoom in (fewer bars)
    const oldVis = state.visibleBars;
    const newVis = clamp(Math.round(oldVis * factor), 20, 700);
    if (newVis === oldVis) return;

    $("follow").checked = false;
    state.follow = false;

    const anchorVIdx = winBefore.startIdx + xFrac * (winBefore.vis - 1);

    state.visibleBars = newVis;
    $("visibleBars").value = String(newVis);

    const endTarget = anchorVIdx + Math.round((1 - xFrac) * (newVis - 1));
    state.rightOffset = winBefore.lastIdx - endTarget;

    clampOffset();
  }, { passive:false });

  // prevent context menu
  canvas.addEventListener("contextmenu", (e) => e.preventDefault());

  // ===== Pointer events: pan X/Y + pinch zoom X + tap actions
  let tapCandidate = null;

  canvas.addEventListener("pointerdown", (e) => {
    canvas.setPointerCapture(e.pointerId);
    state.pointers.set(e.pointerId, { x: e.clientX, y: e.clientY });

    // if follow enabled, disable on first interaction
    if (state.follow) {
      $("follow").checked = false;
      state.follow = false;
    }

    tapCandidate = {
      id: e.pointerId,
      x: e.clientX, y: e.clientY,
      t: performance.now(),
      ctrl: e.ctrlKey,
      alt: e.altKey,
      button: e.button
    };

    // if ctrl/alt -> don't start pan (we want click actions)
    const isModifierClick = e.ctrlKey || e.altKey;

    if (state.pointers.size === 1) {
      canvas.style.cursor = "grabbing";
      state.cross.on = true;

      if (!isModifierClick) {
        // choose pan mode
        const mode = (e.shiftKey || e.button === 2) ? "y" : "x";

        // capture current pricePerPixel for Y pan
        let pricePerPx = 0.2;
        const win = getWindowBars();
        if (win.vis) {
          const lo = Math.ceil(win.startIdx);
          const hi = Math.floor(win.endIdx);
          const barsInView = win.all.filter(b => b.idx >= lo && b.idx <= hi);
          const pr = computePriceRange(barsInView.length ? barsInView : win.all.slice(-80));
          const geo = buildGeo(win.vis, pr, win.startIdx);
          pricePerPx = (pr.max - pr.min) / Math.max(1, (geo.plotY1 - geo.plotY0));
        }

        state.panStart = {
          mode,
          x0: e.clientX,
          y0: e.clientY,
          rightOffset: state.rightOffset,
          yOffset: state.yOffset,
          stepPx: stepPxScreen(),
          pricePerPx
        };
      } else {
        state.panStart = null;
      }

      state.pinchStart = null;
    } else if (state.pointers.size === 2) {
      const pts = [...state.pointers.values()];
      const dist = Math.hypot(pts[0].x - pts[1].x, pts[0].y - pts[1].y);
      state.pinchStart = { dist, visibleBars: state.visibleBars };
      state.panStart = null;
      state.cross.on = false;
    }
  });

  canvas.addEventListener("pointermove", (e) => {
    if (!state.pointers.has(e.pointerId)) return;
    state.pointers.set(e.pointerId, { x: e.clientX, y: e.clientY });

    applySettingsFromUI();

    // pinch zoom (X)
    if (state.pointers.size === 2 && state.pinchStart) {
      const pts = [...state.pointers.values()];
      const dist = Math.hypot(pts[0].x - pts[1].x, pts[0].y - pts[1].y);
      const ratio = dist / Math.max(1, state.pinchStart.dist);
      const newVis = clamp(Math.round(state.pinchStart.visibleBars / ratio), 20, 700);
      state.visibleBars = newVis;
      $("visibleBars").value = String(newVis);
      return;
    }

    // pan
    if (state.pointers.size === 1 && state.panStart) {
      const dx = e.clientX - state.panStart.x0;
      const dy = e.clientY - state.panStart.y0;

      if (state.panStart.mode === "x") {
        const barsDelta = Math.round(-dx / Math.max(2, state.panStart.stepPx));
        state.rightOffset = state.panStart.rightOffset + barsDelta;
        clampOffset();
      } else {
        // Y pan: dragging down increases yOffset -> candles go down, shows higher prices (TV-like)
        state.yOffset = state.panStart.yOffset + dy * state.panStart.pricePerPx;
        statsDirty = true;
      }
    }

    // crosshair update
    const pt = canvasPointFromClient(e);
    const win = getWindowBars();
    if (win.vis) {
      const lo = Math.ceil(win.startIdx);
      const hi = Math.floor(win.endIdx);
      const barsInView = win.all.filter(b => b.idx >= lo && b.idx <= hi);
      const pr = computePriceRange(barsInView.length ? barsInView : win.all.slice(-80));
      const geo = state.geo ?? buildGeo(win.vis, pr, win.startIdx);

      const idx = idxFromX(pt.x, geo);
      const price = priceFromY(pt.y, pr, geo);

      state.cross.x = pt.x;
      state.cross.y = pt.y;
      state.cross.idx = idx;
      state.cross.price = price;
      state.cross.on = true;
    }
  });

  function handleTap(clientX, clientY, mods) {
    const win = getWindowBars();
    if (!win.vis) return;

    const lo = Math.ceil(win.startIdx);
    const hi = Math.floor(win.endIdx);
    const barsInView = win.all.filter(b => b.idx >= lo && b.idx <= hi);
    const pr = computePriceRange(barsInView.length ? barsInView : win.all.slice(-80));
    const geo = state.geo ?? buildGeo(win.vis, pr, win.startIdx);

    const pt = canvasPointFromClient({ clientX, clientY });

    if (pt.x < geo.plotX0 || pt.x > geo.plotX1 || pt.y < geo.plotY0 || pt.y > geo.plotY1) return;

    const idx = idxFromX(pt.x, geo);
    const price = priceFromY(pt.y, pr, geo);
    if (idx == null) return;

    if (mods && mods.alt) {
      const ok = cancelNearestLimitByPrice(price);
      if (!ok) log("‚ö†Ô∏è –ù–µ—Ç –ª–∏–º–∏—Ç–∫–∏ —Ä—è–¥–æ–º –ø–æ —Ü–µ–Ω–µ (Alt+Click).", "warn");
      return;
    }
    if (mods && mods.ctrl) {
      const side = (mods.button === 2) ? "sell" : "buy";
      placeLimit(side, price, getQty());
      return;
    }
  }

  function pointerUpCommon(e) {
    if (state.pointers.has(e.pointerId)) state.pointers.delete(e.pointerId);

    if (tapCandidate && tapCandidate.id === e.pointerId) {
      const dt = performance.now() - tapCandidate.t;
      const dx = Math.abs(e.clientX - tapCandidate.x);
      const dy = Math.abs(e.clientY - tapCandidate.y);
      const isTap = (dt < 260 && dx < 8 && dy < 8);
      if (isTap) handleTap(e.clientX, e.clientY, tapCandidate);
      tapCandidate = null;
    }

    if (state.pointers.size === 0) {
      canvas.style.cursor = "grab";
      state.panStart = null;
      state.pinchStart = null;
    } else if (state.pointers.size === 1) {
      const only = [...state.pointers.values()][0];
      state.panStart = { mode:"x", x0: only.x, y0: only.y, rightOffset: state.rightOffset, yOffset: state.yOffset, stepPx: stepPxScreen(), pricePerPx: 0.2 };
      state.pinchStart = null;
    }
  }
  canvas.addEventListener("pointerup", pointerUpCommon);
  canvas.addEventListener("pointercancel", pointerUpCommon);

  // ===== Buttons
  function buyMarket() { syncLeftFromTop(); marketOrder("buy", getQty(), getSlip()); }
  function sellMarket(){ syncLeftFromTop(); marketOrder("sell", getQty(), getSlip()); }

  $("buyMktTop").addEventListener("click", buyMarket);
  $("sellMktTop").addEventListener("click", sellMarket);
  $("qtyTop").addEventListener("input", syncLeftFromTop);
  $("slipTop").addEventListener("input", syncLeftFromTop);

  $("followWrap").addEventListener("click", (e) => {
    if (e.target.tagName !== "INPUT") $("follow").checked = !$("follow").checked;
    state.follow = $("follow").checked;
    if (state.follow) state.rightOffset = -state.followPad;
  });

  $("placeLimit").addEventListener("click", () => {
    const side = $("limitSide").value;
    const qty = getQty();
    const price = Number($("limitPrice").value || 0);
    if (!Number.isFinite(price) || price <= 0) { log("‚ö†Ô∏è –í–≤–µ–¥–∏ —Ü–µ–Ω—É –ª–∏–º–∏—Ç–∫–∏ (> 0).", "warn"); return; }
    placeLimit(side, price, qty);
  });

  $("cancelAll").addEventListener("click", cancelAll);
  $("flatten").addEventListener("click", flatten);

  $("clearLog").addEventListener("click", () => $("log").innerHTML = "");

  $("pause").addEventListener("click", () => {
    state.paused = !state.paused;
    $("pause").textContent = state.paused ? "‚ñ∂Ô∏è Resume" : "‚è∏Ô∏è Pause";
    log(state.paused ? "‚è∏Ô∏è Market paused" : "‚ñ∂Ô∏è Market resumed", "warn");
  });

  function resetView() {
    state.yScale = 1.0;
    state.yOffset = 0.0;
    state.visibleBars = Number($("visibleBars").value || 160);
    if (state.follow) state.rightOffset = -state.followPad;
    clampOffset();
    statsDirty = true;
  }
  $("resetView").addEventListener("click", resetView);

  $("reset").addEventListener("click", () => {
    state.price = 17000;
    state.velocity = 0;
    state.pos = 0;
    state.avg = null;

    state.limits = [];
    state.bars = [];
    state.lastBarIdx = 0;
    state._curBar = null;
    state._barCounter = 0;

    state.yScale = 1.0;
    state.yOffset = 0.0;

    $("follow").checked = true;
    state.follow = true;
    state.rightOffset = -state.followPad;

    applySettingsFromUI();
    seedHistory(260);

    $("limitPrice").value = state.price.toFixed(2);

    ordersDirty = true;
    statsDirty = true;

    log("üîÅ Reset done", "warn");
  });

  $("stepTick").addEventListener("click", () => {
    if (!state.paused) { log("‚ö†Ô∏è Step —Ä–∞–±–æ—Ç–∞–µ—Ç —Ç–æ–ª—å–∫–æ –Ω–∞ –ø–∞—É–∑–µ.", "warn"); return; }
    stepSimulationOnce();
  });

  // speed buttons
  document.querySelectorAll(".speedBtn").forEach(btn => {
    btn.addEventListener("click", () => {
      const v = Number(btn.dataset.speed || "1");
      state.speedMul = clamp(v, 0.1, 50);
      document.querySelectorAll(".speedBtn").forEach(b => b.classList.toggle("active", b === btn));
      statsDirty = true;
    });
  });

  // Simple/Advanced mode (default is simple)
  $("toggleMode").addEventListener("click", () => {
    document.body.classList.toggle("simple");
    const isSimple = document.body.classList.contains("simple");
    $("toggleMode").textContent = isSimple ? "üß© Advanced" : "üß© Simple";
  });

  // Help overlay
  const helpOverlay = $("helpOverlay");
  function openHelp(){ helpOverlay.classList.add("open"); }
  function closeHelp(){ helpOverlay.classList.remove("open"); }
  $("openHelp").addEventListener("click", openHelp);
  $("closeHelp").addEventListener("click", closeHelp);
  helpOverlay.addEventListener("click", (e) => { if (e.target === helpOverlay) closeHelp(); });

  // settings listeners
  ["vol","liq","impact","simHzBase","tick","spread","timeframe","visibleBars","follow"].forEach(id => {
    $(id).addEventListener("change", () => {
      applySettingsFromUI();
      if (state.follow) state.rightOffset = -state.followPad;
      statsDirty = true;
    });
  });

  // Hotkeys
  window.addEventListener("keydown", (e) => {
    const tag = (document.activeElement && document.activeElement.tagName) || "";
    const typing = tag === "INPUT" || tag === "TEXTAREA" || tag === "SELECT";
    if (typing) return;

    const k = e.key.toLowerCase();

    if (k === "?") { e.preventDefault(); helpOverlay.classList.toggle("open"); return; }
    if (k === "b") { buyMarket(); return; }
    if (k === "s") { sellMarket(); return; }
    if (k === "f") {
      $("follow").checked = !$("follow").checked;
      state.follow = $("follow").checked;
      if (state.follow) state.rightOffset = -state.followPad;
      return;
    }
    if (k === " ") { e.preventDefault(); $("pause").click(); return; }
    if (k === "c") { cancelAll(); return; }
    if (k === "x") { flatten(); return; }
    if (k === "+") { setQty(getQty() + 1); return; }
    if (k === "-") { setQty(getQty() - 1); return; }
    if (k === "r") { resetView(); return; }
  });

  // ===== Seed history so chart doesn't start empty
  function seedHistory(nBars = 240) {
    // build nBars OHLC around current price
    const tick = state.tickSize;
    let p = state.price;
    let idx = 0;

    const bars = [];
    for (let i = 0; i < nBars; i++) {
      const o = p;
      let h = p, l = p;

      // simulate some internal steps per bar
      const steps = 30 + Math.floor(Math.random() * 25);
      for (let s = 0; s < steps; s++) {
        const r = (Math.random()+Math.random()+Math.random()-1.5);
        p = roundTo(p + r * tick * (0.9 + Math.random() * 1.2), tick);
        h = Math.max(h, p);
        l = Math.min(l, p);
      }
      const c = p;

      idx++;
      bars.push({ idx, o, h, l, c });
    }

    state.bars = bars;
    state.lastBarIdx = bars[bars.length - 1].idx;
    state.price = bars[bars.length - 1].c;

    state._curBar = { idx: state.lastBarIdx + 1, o: state.price, h: state.price, l: state.price, c: state.price };
    state._barCounter = 0;

    if (state.follow) state.rightOffset = -state.followPad;
    clampOffset();
  }

  // ===== UI throttle
  setInterval(() => {
    if (statsDirty) { renderStats(); statsDirty = false; }
    if (ordersDirty) { renderOrdersTable(); ordersDirty = false; }
  }, 100);

  // ===== loop (canvas)
  function init() {
    $("limitPrice").value = state.price.toFixed(2);
    $("visibleBars").value = String(state.visibleBars);
    resizeCanvasToDisplaySize();

    applySettingsFromUI();
    seedHistory(260);

    log("–ì–æ—Ç–æ–≤–æ: TV-like navigation (–ø—É—Å—Ç–æ—Ç–∞ —Å–ª–µ–≤–∞/—Å–ø—Ä–∞–≤–∞ + seed history + X/Y zoom/pan).", "warn");
  }

  let lastTs = performance.now();
  let acc = 0;

  function loop(ts) {
    const dt = (ts - lastTs) / 1000;
    lastTs = ts;

    applySettingsFromUI();

    const step = 1 / state.simHz;
    if (!state.paused) {
      acc += dt;
      acc = Math.min(acc, 0.25);
      while (acc >= step) {
        stepSimulationOnce();
        acc -= step;
      }
    }

    if (state.follow) state.rightOffset = -state.followPad;
    clampOffset();

    drawChart();
    requestAnimationFrame(loop);
  }

  init();
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
